<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Day.28 「Promise 初體驗～」 —— ES6 Promise</title>
    <link href="/2021/10/07/2021-10-7-it_ironman-day28/"/>
    <url>/2021/10/07/2021-10-7-it_ironman-day28/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-28-「Promise-初體驗～」-——-ES6-Promise"><a href="#Day-28-「Promise-初體驗～」-——-ES6-Promise" class="headerlink" title="Day.28 「Promise 初體驗～」 —— ES6 Promise"></a>Day.28 「Promise 初體驗～」 —— ES6 Promise</h1><p><img src="https://i.imgur.com/BnUYCE5.png" alt="「Promise 初體驗～」 —— ES6 Promise"></p><p>我們前面已經學習了<strong>回調函式</strong>（<strong>Callback Function</strong>）與<strong>構造函式</strong>（<strong>Constrcutor</strong>），而 Promise 是 ES6 新增用來解決<strong>非同步回調地域</strong>的新語法，同時也是一個構造函式！</p><h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>在這裡我們要先了解到什麼是非同步！相信大家應該都聽過最好理解的範例，那就是用餐廳來做範例！</p><p>同步的概念就像是：服務生接收點餐 → 通知廚房有餐 → 廚房完成餐點 → 結帳 → 接下一位客人<br>一步一步做下去，優點是不易出錯，但缺點也非常明顯，效率非常差。</p><p>而非同步的概念：服務生接收點餐 → 通知廚房有餐 → 結帳 → 接下一位客人 → … → 廚房完成餐點一起給客人<br>能夠把需要先執行的優先執行，優點就是效率好，但缺點就是跟同步比起來，維護比較麻煩。</p><p>而在我們介紹定時器時，就有體現出<strong>非同步</strong>的狀態。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">order</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;點餐&quot;</span>);<br>  <br>    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">making</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;開始製作&quot;</span>);<br><br>        (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkout</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;結帳&quot;</span>);<br>        &#125;)();<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;餐點完成&quot;</span>);<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;)();<br>&#125;<br><br>order();<br>order();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    &quot;點餐&quot;</span><br><span class="hljs-comment">    &quot;開始製作&quot;</span><br><span class="hljs-comment">    &quot;結帳&quot;</span><br><span class="hljs-comment">    &quot;點餐&quot;</span><br><span class="hljs-comment">    &quot;開始製作&quot;</span><br><span class="hljs-comment">    &quot;結帳&quot;</span><br><span class="hljs-comment">    &quot;餐點完成&quot;</span><br><span class="hljs-comment">    &quot;餐點完成&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>這時就有點看到<strong>回調地獄</strong>（<strong>Callback Hell</strong>）的影子了！這就是它<strong>不容易維護</strong>的部分</p><ul><li>不易閱讀</li><li>處理異常處理不方便</li></ul><p>而 Promise 改善了回調地獄的問題。</p><h2 id="ES6-以前"><a href="#ES6-以前" class="headerlink" title="ES6 以前"></a>ES6 以前</h2><p>在還沒有 ES6 前，處理 AJAX 與 計時器的時候，都是直接使用回調函式來處理<strong>非同步事件</strong><br>這裡用抽獎為例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>點我抽獎<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);  <span class="hljs-comment">// 獲取按鈕 DOM</span><br><br><span class="hljs-comment">/*  隨機數函式  */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomNum</span> (<span class="hljs-params">m, n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil( <span class="hljs-built_in">Math</span>.random() * (n - m + <span class="hljs-number">1</span>)) + m - <span class="hljs-number">1</span>;<br>&#125;<br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 設定按按鈕後一秒後抽獎</span><br>  <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = randomNum(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 1~100 隨機數</span><br>    <span class="hljs-keyword">if</span> ( n &lt;= <span class="hljs-number">30</span> ) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;恭喜你中獎了！你的中獎數字是&quot;</span> + n);  <span class="hljs-comment">// 30% 中獎率</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;銘謝惠顧～你的數字是&quot;</span> + n)<br>    &#125;<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>在 ES6 之後，可以透過 Promise 來包裝程式碼，<br>而使用 Promise 的方式，與構造函式的使用方式類同，而參數帶入的是<strong>函式</strong>，帶入的函式內會有<strong>兩個參數</strong> <code>resolve</code> 、 <code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>這兩個參數本身也是函式，一個代表<strong>解決</strong>，一個代表<strong>拒絕</strong>，函式的參數可以進行傳遞。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;成功&quot;</span>) &#123;<br>    resolve( <span class="hljs-string">&quot;成功&quot;</span> );  <span class="hljs-comment">// 成功使用 resolve 函式，代表這個 Promise 物件的狀態是成功的</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    reject( <span class="hljs-string">&quot;失敗&quot;</span> );    <span class="hljs-comment">// 失敗使用 reject 函式，代表這個 Promise 物件的狀態是失敗的</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>以上面的抽獎例子做修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 修改事件監聽，進行 Promise 包裝 */</span><br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// Promise 包裝</span><br>    <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> n = randomNum(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 1~100 隨機數</span><br>      <span class="hljs-keyword">if</span> ( n &lt;= <span class="hljs-number">30</span> ) &#123;<br>        resolve(n);  <span class="hljs-comment">// 將 Promise 物件設定為&quot;成功&quot; n 作為資料參數傳遞出去</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(n);   <span class="hljs-comment">// 將 Promise 物件設定為&quot;失敗&quot; n 作為資料參數傳遞出去</span><br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>)<br>    <br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>這樣就包裝好了，但你會發現，奇怪怎麼沒有效果了？<br>那是因為還要調用 <code>then</code> 方法，來接收成功或失敗的資料，一樣可以接收兩個參數，兩個參數分別代表<strong>成功</strong>與<strong>失敗</strong>的函式，而成功與失敗的函式可以靠參數傳遞資料。</p><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;恭喜你中獎了！你的中獎數字是&quot;</span> + data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;銘謝惠顧～你的數字是&quot;</span> + err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>你可能覺得，好像沒有方便到哪裡呀～還要另外用 <code>then</code> 來調用！<br>那是因為我們這個範例還很簡單，沒有到 Callback Hell 的程度，當資料越來越複雜，就會形成 Callback Hell。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// node.js 資料串接</span><br>data.readFile(<span class="hljs-string">&#x27;./data/a.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data1</span>) =&gt;</span> &#123;<br>    data.readFile(<span class="hljs-string">&#x27;./data/b.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data2</span>) =&gt;</span> &#123;<br>        data.readFile(<span class="hljs-string">&#x27;./data/c.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data3</span>) =&gt;</span> &#123;<br>            data.readFile(<span class="hljs-string">&#x27;./data/d.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data4</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">let</span> result = data1 + data2 + data3 + data4;<br>                <span class="hljs-built_in">console</span>.log(result)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>而 <code>Promise</code> 只要包裝好了，接下來只要使用 <code>then</code> 來進行連續調用串接，不會讓程式碼越來越往右推移。<br>此外大多數情況，也不會刻意接失敗的資料，可以依靠 <code>catch</code> 來進行最後<strong>失敗</strong>時的處理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 先在最外層進行 Promise 包裝</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> &#123;<br>  data.readFile(<span class="hljs-string">&#x27;./data/a.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    res(data);<br>  &#125;)<br>&#125;)<br><span class="hljs-comment">// 使用 then 串接</span><br>p.then( <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    data.readFile(<span class="hljs-string">&#x27;./data/b.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      res([val, data]);<br>    &#125;)<br>  &#125;)<br>&#125;).then( <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    data.readFile(<span class="hljs-string">&#x27;./data/c.text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      val.push(data);<br>      res(val)<br>    &#125;)<br>  &#125;)<br>&#125;).then( <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(val)  <span class="hljs-comment">// 成功使用 then</span><br>&#125;).catch( <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;串接失敗！&quot;</span>)  <span class="hljs-comment">// 失敗使用 catch</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然<strong>短期</strong>這樣看，Promise 寫起來好像沒有 Callback 快，但它<strong>解決了長期的資料變龐大</strong>的時候，所產生的<strong>回調地獄</strong>，Promise 只是<strong>向下</strong>添加程式碼，而 Callback Hell 則是一直<strong>往右</strong>推移程式碼，Promise 還有很多方法還沒講到，目前只是初體驗！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li><li><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/">JavaScript Promise 全介紹</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.29 「Class 語法糖～」 —— ES6 Class 構造函式</title>
    <link href="/2021/10/07/2021-10-8-it_ironman-day29/"/>
    <url>/2021/10/07/2021-10-8-it_ironman-day29/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-29-「Class-語法糖～」-——-ES6-Class-構造函式"><a href="#Day-29-「Class-語法糖～」-——-ES6-Class-構造函式" class="headerlink" title="Day.29 「Class 語法糖～」 —— ES6 Class 構造函式"></a>Day.29 「Class 語法糖～」 —— ES6 Class 構造函式</h1><p><img src="https://i.imgur.com/EOelHe0.png" alt="「Class 語法糖～」 —— ES6 Class 構造函式"></p><p>ES6 新增了更接近傳統語言寫法的 Class 這個概念，基本上可以當作是一個<strong>語法糖</strong>，絕大部分的功能在 ES5 都可以做到，但 Class 可以讓構造函式的寫法更加清新！</p><blockquote><p>什麼是語法糖？<br>就是新增的語法對原功能沒有什麼影響，主要是給程式開發者更方便的使用。</p></blockquote><h2 id="class-初體驗"><a href="#class-初體驗" class="headerlink" title="class 初體驗"></a>class 初體驗</h2><p>首先，我們先用之前的構造函式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-comment">// 構造函式方法傳給原型鍊</span><br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>person.sayName();  <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br></code></pre></td></tr></table></figure><p>接著來使用 <code>class</code> 構造函式，來看看差異，可以發現<strong>繼承方法</strong>可以寫在構造函式內，它會<strong>自動</strong>幫我們傳給原型鍊上，而物件資料寫在 <code>constructor</code> 內</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 構造函式方法，一定要使用 constructor 不能改名</span><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">name, gender</span>) &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.gender = gender;<br>  &#125;<br>  <br>  sayName () &#123;  <span class="hljs-comment">// 添加方法必須使用這個語法</span><br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name ); <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>person.sayName();  <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br><span class="hljs-built_in">console</span>.log(person);<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/WRcvc2h.png" alt="自動傳給繼承鍊上"></p><h2 id="靜態屬性"><a href="#靜態屬性" class="headerlink" title="靜態屬性"></a>靜態屬性</h2><p>我們都知道構造函式也是物件，ES6 以前構造函式要添加靜態屬性，就是使用物件的方法來添加，因為沒有使用到原型鍊，所以這個屬性是 <code>Person</code> 內的屬性，也就是<strong>靜態屬性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>Person.type = <span class="hljs-string">&quot;人類&quot;</span>;<br><br><span class="hljs-keyword">const</span> mao = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(mao.type);     <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(Person.type);  <span class="hljs-comment">// &quot;人類&quot;</span><br></code></pre></td></tr></table></figure><h3 id="static-靜態方法"><a href="#static-靜態方法" class="headerlink" title="static 靜態方法"></a>static 靜態方法</h3><p>而 class 有新增靜態方法 <code>static</code>，來實現靜態屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>()</span>&#123;<br>  <span class="hljs-keyword">static</span> type = <span class="hljs-string">&quot;人類&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> mao = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(mao.type);     <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(Person.type);  <span class="hljs-comment">// &quot;人類&quot;</span><br></code></pre></td></tr></table></figure><h2 id="構造函式繼承"><a href="#構造函式繼承" class="headerlink" title="構造函式繼承"></a>構造函式繼承</h2><p>ES6 以前要寫構造函式繼承構造函式時</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*  父級構造函式，人  */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-comment">/*  子級構造函式，成年人  */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AdultPerson</span> (<span class="hljs-params">name, gender, age, married</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name, gender);  <span class="hljs-comment">// 透過 call 方法來繼承父級構造函式資料</span><br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.married = married;<br>&#125;<br><span class="hljs-comment">/*  設定子級構造函式的原型  */</span><br>AdultPerson.prototype = <span class="hljs-keyword">new</span> Person;<br><span class="hljs-comment">/*  校正子級構造函式的 constructor  */</span><br>AdultPerson.prototype.constructor = AdultPerson;<br><br><span class="hljs-keyword">const</span> mao = <span class="hljs-keyword">new</span> AdultPerson(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;未婚&quot;</span>);<br>mao.sayName(); <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br><span class="hljs-built_in">console</span>.log(mao);<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UIg96dj.png" alt="子級構造函式繼承父級構造函式"></p><p>可以看到使用子級構造函式，可以繼承父級構造函式的方法 <code>sayName</code>。</p><h3 id="extends-繼承方法"><a href="#extends-繼承方法" class="headerlink" title="extends 繼承方法"></a>extends 繼承方法</h3><p>而 class 有新增繼承方法 <code>extends</code> 與 <code>super</code>，來實現繼承父級構造函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 構造函式方法，一定要使用 constructor 不能改名</span><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">name, gender</span>) &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.gender = gender;<br>  &#125;<br>  <br>  sayName () &#123;  <span class="hljs-comment">// 添加方法必須使用這個語法</span><br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name ); <br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdultPerson</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123; <span class="hljs-comment">// 使用 extends 繼承父級構造函式</span><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">name, gender, age, married</span>) &#123;<br>    <span class="hljs-comment">// 使用 super 調用父級構造函式的屬性方法</span><br>    <span class="hljs-built_in">super</span>(name, gender);   <span class="hljs-comment">// 與 Person.call(this, name, gender) 效果一樣</span><br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.married = married;<br>  &#125;<br>  <span class="hljs-comment">/*  可以自己新增方法  */</span><br>&#125;<br><br><span class="hljs-keyword">const</span> mao = <span class="hljs-keyword">new</span> AdultPerson(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;未婚&quot;</span>);<br>mao.sayName(); <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br><span class="hljs-built_in">console</span>.log(mao);<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/SQ5hL6e.png" alt="子級構造函式繼承父級構造函式"></p><p>使用起來，更簡潔有利～也更加直覺可以判斷是兩個構造函式與之間的關係！</p><h2 id="getter-與-setter"><a href="#getter-與-setter" class="headerlink" title="getter 與 setter"></a>getter 與 setter</h2><p>class 的 <code>get</code> 與 <code>set</code> 方法，<br>在對某個屬性<strong>讀取</strong>時，會調用 <code>get</code> 對應的函式，<br>在對某個屬性<strong>設置</strong>時，會調用 <code>set</code> 對應的函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 構造函式方法，一定要使用 constructor 不能改名</span><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  get name () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;名字被讀取&quot;</span>);<br>  &#125;<br>  set name (newVal) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;名字被修改為&quot;</span> + newVal);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> mao = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>);  <span class="hljs-comment">// 這時會自動調 set name 方法，&quot;名字被修改為毛毛&quot;</span><br><span class="hljs-built_in">console</span>.log(mao.name);    <span class="hljs-comment">// 這時會自動調 get name 方法，&quot;名字被讀取&quot;</span><br>mao.name = <span class="hljs-string">&quot;鮭魚&quot;</span>;  <span class="hljs-comment">// 這時會自動調 set name 方法，&quot;名字被修改為鮭魚&quot;</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>Class 這個語法糖，讓我們寫構造函式會更加方便直觀，用過都說回不去了！</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.27 「var 成為時代的眼淚！」 —— ES6 區塊作用域 與 提升</title>
    <link href="/2021/10/06/2021-10-6-it_ironman-day27/"/>
    <url>/2021/10/06/2021-10-6-it_ironman-day27/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-27-「var-成為時代的眼淚！」-——-ES6-區塊作用域-與-提升"><a href="#Day-27-「var-成為時代的眼淚！」-——-ES6-區塊作用域-與-提升" class="headerlink" title="Day.27 「var 成為時代的眼淚！」 —— ES6 區塊作用域 與 提升"></a>Day.27 「var 成為時代的眼淚！」 —— ES6 區塊作用域 與 提升</h1><p><img src="https://i.imgur.com/hAS4sZ7.png" alt="「var 成為時代的眼淚！」 —— ES6 區塊作用域 與 提升"></p><p>之前已經介紹了 <code>var</code> 與<strong>函式作用域</strong>，今天來更仔細的介紹 ES6 新增的 <code>let</code> 、 <code>const</code>以及與它們相關的<strong>區塊作用域</strong></p><h2 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h2><p>與<strong>函式作用域</strong>有點像，一樣都是作用域內沒有的變數可以<strong>往外獲取</strong>變數，不一樣的是更嚴格謹慎，不只限制在函式上了，連 <code>if else</code> 、 <code>while</code> 、 <code>for</code> 這些循環語句都有限制不能從外往內取，稱為<strong>區塊作用域</strong>（<strong>Block Scope</strong>）。</p><p>以常見的 <code>var</code> 全域汙染為例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;&#125;<br><span class="hljs-built_in">console</span>.log( i );    <span class="hljs-comment">// 3，成功在 for 迴圈外面獲取到 for 迴圈內的 i = 3</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;&#125;<br><span class="hljs-built_in">console</span>.log( a );    <span class="hljs-comment">// 報錯， a is not defined</span><br></code></pre></td></tr></table></figure><h2 id="let-的特性"><a href="#let-的特性" class="headerlink" title="let 的特性"></a>let 的特性</h2><p><code>let</code> 跟我們常用的 <code>var</code> 用法非常相似，但也是有不同的地方！</p><ul><li><p><code>let</code> 不可重複宣告</p><ul><li><p>使用 <code>var</code> 重複宣告不會報錯，只會覆蓋掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;小黃&quot;</span>;  <span class="hljs-comment">// 使用 var 重複宣告不會報錯，只會覆蓋掉</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>let</code> 重複宣告會報錯</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;小黃&quot;</span>;  <span class="hljs-comment">// 使用 let 重複宣告會報錯</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>區塊作用域</p><ul><li><p>使用 <code>var</code> 容易汙染全域作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;&#125;<br><span class="hljs-built_in">console</span>.log( i );    <span class="hljs-comment">// 成功在 for 迴圈外面獲取到 i = 3</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>let</code> 則能讓變數限制在區塊內</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;&#125;<br><span class="hljs-built_in">console</span>.log( i );    <span class="hljs-comment">// 報錯， i is not defined</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>變數提升效果不同</p><ul><li><p>使用 <code>var</code> 會自動提升，並顯示<strong>未定義</strong> <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(name);  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>let</code> 宣告比較嚴謹，會直接報錯（也就是俗稱的死區），讓 debug 效率變高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(name);  <span class="hljs-comment">// 報錯</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="const-的特性"><a href="#const-的特性" class="headerlink" title="const 的特性"></a>const 的特性</h2><ul><li><p>必須要賦初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PI;  <span class="hljs-comment">// 報錯</span><br></code></pre></td></tr></table></figure></li><li><p>常數不能修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14159265</span>;<br>PI++  <span class="hljs-comment">// 報錯</span><br></code></pre></td></tr></table></figure></li><li><p>一樣也具有區塊作用域</p></li><li><p>對陣列或物件內的<strong>屬性</strong>做修改，並不會報錯</p><ul><li>因為我們知道物件型別存的是<strong>參考（地址）</strong>，只要 Stack 值不變就不會報錯<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span> &#125;;<br>person.name = <span class="hljs-string">&quot;鮭魚&quot;</span>;<br>person.age = <span class="hljs-number">27</span>;<br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// &#123; name: &quot;鮭魚&quot;, gender: &quot;男&quot;, age: 27 &#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>會使用 <code>let</code> 與 <code>const</code> 後，就比較少使用到 <code>var</code> 了，在宣告<strong>物件型別</strong>或<strong>不會主動修改值</strong>得變數都會建議使用 <code>const</code> 來宣告！這樣比較不容易變動到變數而出現意想不到的 bug。</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.26 「閉包要謹慎使用！」 —— JavaScript 閉包（Closure）</title>
    <link href="/2021/10/05/2021-10-5-it_ironman-day26/"/>
    <url>/2021/10/05/2021-10-5-it_ironman-day26/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-26-「閉包要謹慎使用！」-——-JavaScript-閉包（Closure）"><a href="#Day-26-「閉包要謹慎使用！」-——-JavaScript-閉包（Closure）" class="headerlink" title="Day.26 「閉包要謹慎使用！」 —— JavaScript 閉包（Closure）"></a>Day.26 「閉包要謹慎使用！」 —— JavaScript 閉包（Closure）</h1><p><img src="https://i.imgur.com/2KRYZOP.png" alt="「閉包要謹慎使用！」 —— JavaScript 閉包（Closure）"></p><p>我們前面已經認識了<strong>函式作用域</strong>，也瞭解了<strong>回調函式</strong>，但有時候會產生意想不到的事情，造成內存問題，其中一個是<strong>閉包</strong></p><h2 id="認識閉包"><a href="#認識閉包" class="headerlink" title="認識閉包"></a>認識閉包</h2><h3 id="閉包是如何產生的？"><a href="#閉包是如何產生的？" class="headerlink" title="閉包是如何產生的？"></a>閉包是如何產生的？</h3><p>閉包通常出現在<strong>巢狀函式</strong>中，是<strong>內部函式</strong>使用了<strong>外部函式</strong>的<strong>變數</strong>時，產生<strong>閉包</strong>！</p><h3 id="閉包是什麼？"><a href="#閉包是什麼？" class="headerlink" title="閉包是什麼？"></a>閉包是什麼？</h3><p>首先我們用簡單的範例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a++<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> plus1;<br>&#125;<br><br><span class="hljs-keyword">var</span> f = fn();<br>f();<br></code></pre></td></tr></table></figure><p>我們透過 Google Chrome 的開發人員工具查看執行過程</p><p><img src="https://i.imgur.com/nzgr4g1.png" alt="Google Chrome 的開發人員工具"></p><p>可以看到在執行到第 8 行的時候，產生了閉包，也就是紅框處！</p><p>由此可見～閉包是在我們<strong>內部函式</strong>使用到了<strong>外部函式的變數</strong>時產生出來。<br>你可能想說第 9 行函式還沒執行呀！？<br>那是因為，函式的<strong>提升</strong>，所以導致執行到函式變數的時候就產生閉包。<br>而這時有被<strong>內部函式</strong>使用的<strong>變數</strong>，就會存在閉包之中！</p><h2 id="常見的閉包"><a href="#常見的閉包" class="headerlink" title="常見的閉包"></a>常見的閉包</h2><h3 id="內部函式-為-外部函式-的返回值"><a href="#內部函式-為-外部函式-的返回值" class="headerlink" title="內部函式 為 外部函式 的返回值"></a>內部函式 為 外部函式 的返回值</h3><p>就是我們上面的範例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a++<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> plus1;<br>&#125;<br><br><span class="hljs-keyword">var</span> f = fn();<br><br>f();  <span class="hljs-comment">// 2</span><br>f();  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>你會發現！函式內的變數 <code>a</code> 還存在可以累加並<strong>沒有消失</strong>，而這個值就存在 <code>f</code> 函式的閉包中！</p><h3 id="回調函式"><a href="#回調函式" class="headerlink" title="回調函式"></a>回調函式</h3><p>沒錯！回調函式也會產生閉包～如下面範例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">consoleDelay</span> (<span class="hljs-params">msg, time</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(msg)<br>  &#125;, time)<br>&#125;<br><br>consoleDelay(<span class="hljs-string">&quot;我也是閉包&quot;</span>, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p>一樣有形成閉包的條件！內部函式引用了外部函式的變數！</p><p><img src="https://i.imgur.com/QToOFcL.png" alt="我也是閉包"></p><h2 id="閉包的作用"><a href="#閉包的作用" class="headerlink" title="閉包的作用"></a>閉包的作用</h2><ol><li><p>一般函式執行完畢後，就會從內存釋放，而閉包則是把函式內的變數，繼續<strong>保留</strong>在內存中（延長了局部變數的生命週期）。</p></li><li><p>一般函式內的變數無法從外部操作，但閉包可以<strong>間接操控</strong>函式內部的變數值。</p></li></ol><h2 id="閉包的優點與缺點"><a href="#閉包的優點與缺點" class="headerlink" title="閉包的優點與缺點"></a>閉包的優點與缺點</h2><h3 id="閉包的優點同時也是缺點"><a href="#閉包的優點同時也是缺點" class="headerlink" title="閉包的優點同時也是缺點"></a>閉包的優點同時也是缺點</h3><ul><li><p>函式執行完後，函式內的局部變數不會釋放，如果這個局部變數還會使用，那就是優點，如果不會使用了，那就變成缺點，因為佔用內存的時間會變長。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000</span>);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrLength</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;內存有 &quot;</span> + arr.length + <span class="hljs-string">&quot; 長度的陣列&quot;</span> );<br>  &#125;<br>  <span class="hljs-keyword">return</span> arrLength;<br>&#125;<br><br><span class="hljs-keyword">var</span> f = fn();<br>f();  <span class="hljs-comment">// 內存有 10000 長度的陣列</span><br></code></pre></td></tr></table></figure></li><li><p>容易造成內存<strong>溢出</strong>與<strong>洩漏</strong></p><ul><li><strong>內存溢出</strong>比較簡單理解，就是內存不夠跑程式而報錯<br><img src="https://i.imgur.com/VyTDNpk.png" alt="內存溢出"></li><li><strong>內存洩漏</strong>平常還可以正常執行，但每天洩漏一點，會把內存空間壓縮，更容易導致<strong>內存溢出</strong>，常見的內存洩漏<ul><li>意外使用了<strong>全局變數</strong>（宣告習慣很重要），如：函式內忘記使用宣告，直接使用變數</li><li>沒有及時清理的<strong>計時器</strong>或<strong>回調函式</strong></li><li><strong>閉包</strong></li></ul></li></ul></li></ul><h3 id="如何解決"><a href="#如何解決" class="headerlink" title="如何解決"></a>如何解決</h3><ul><li><p>盡量避免濫用閉包</p></li><li><p>及時釋放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 讓內部函式變成「垃圾物件」，瀏覽器會自動清除</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我們已經逐步學習 JavaScript 的核心精隨了！也是面試很長考的觀念～</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.25 「從 事件綁定 與 定時器 認識回調函式！」 —— JavaScript 定時器 &amp; Callback</title>
    <link href="/2021/10/04/2021-10-4-it_ironman-day25/"/>
    <url>/2021/10/04/2021-10-4-it_ironman-day25/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-25-「從-事件綁定-與-定時器-認識回調函式！」-——-JavaScript-定時器-amp-Callback"><a href="#Day-25-「從-事件綁定-與-定時器-認識回調函式！」-——-JavaScript-定時器-amp-Callback" class="headerlink" title="Day.25 「從 事件綁定 與 定時器 認識回調函式！」 —— JavaScript 定時器 &amp; Callback"></a>Day.25 「從 事件綁定 與 定時器 認識回調函式！」 —— JavaScript 定時器 &amp; Callback</h1><p><img src="https://i.imgur.com/oqXdlun.png" alt="「從 事件綁定 與 定時器 認識回調函式！」 —— JavaScript 定時器 &amp; Callback"></p><p>我們前面已經瞭解了事件綁定與事件冒泡了，但是使用 <code>物件元素.綁定事件</code> 有不方便的地方</p><ul><li>只能同時為一個元素的一個事件綁定<strong>一個響應函式</strong></li><li>不能綁定多個，如果綁定多個，後面會覆蓋前面的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是第一個綁定事件&quot;</span>);<br>&#125;<br><br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是第二個綁定事件&quot;</span>);  <span class="hljs-comment">// 這個綁定事件會覆蓋前面的綁定事件</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> &quot;我是第二個綁定事件&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h2><p>這時可以使用最廣泛使用的<strong>事件監聽</strong><br>事件監聽的參數</p><ul><li>第一個參數：要觸發的<strong>事件的字串</strong>，注意不要添加 <code>on</code>，例如：要綁定 <code>onclick</code> 事件，參數就寫 <code>&quot;click&quot;</code></li><li>第二個參數：觸發事件時的<strong>回調函式</strong></li><li>第三個參數：是否再<strong>捕獲階段</strong>觸發，布林值，通常情況下都是 <code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是第一個綁定事件&quot;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是第二個綁定事件&quot;</span>);    <span class="hljs-comment">// 這樣就會直接&quot;添加&quot;綁定事件，而不會覆蓋</span><br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> &quot;我是第一個綁定事件&quot;</span><br><span class="hljs-comment"> &quot;我是第二個綁定事件&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>與普通的事件綁定不一樣，事件監聽是用<strong>添加</strong>事件來綁定的，所以就不會覆蓋前面綁定的事件</p><h2 id="定時器"><a href="#定時器" class="headerlink" title="定時器"></a>定時器</h2><p>而有時候我們並不想透過事件監聽來觸發事件，而是設定時間，在開啟網頁後，一段時間觸發函式。<br>這時就要利用 JavaScript 定時器，就可以達到效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;時間到！&quot;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>而除了 <code>setTimeout</code> 時間到只<strong>觸發一次</strong>的定時器，還有持續一段時間的 <code>setInterval</code> 定時器可以用。</p><h2 id="回調函式（Callback-Function）"><a href="#回調函式（Callback-Function）" class="headerlink" title="回調函式（Callback Function）"></a>回調函式（Callback Function）</h2><p>而我們在<strong>綁定事件</strong>和<strong>定時器</strong>所使用的匿名函式就是所謂的<strong>回調函式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是 DOM 事件的回調函式&quot;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是定時器的回調函式&quot;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><h3 id="回調函式的特點"><a href="#回調函式的特點" class="headerlink" title="回調函式的特點"></a>回調函式的特點</h3><ul><li>我們自己<strong>設置</strong>的，<del>這好像廢話</del></li><li>我們<strong>沒有主動調用</strong>，讓函式變成另一個函式的<strong>參數</strong></li><li>但它自己會<strong>自動調用</strong>，讓<strong>函式控制</strong>參數函式的執行時機</li></ul><p>所以上面看到的 <code>addEventListener()</code> 與 <code>setTimeout()</code> ，顯而易見的都是函式！<br>而我們自己定義的函式就做為參數，等時機到了執行。</p><h3 id="常見的回調函式？"><a href="#常見的回調函式？" class="headerlink" title="常見的回調函式？"></a>常見的回調函式？</h3><p>常見的回調函式有四個</p><ul><li>DOM 事件回調函式</li><li>定時器回調函式</li><li>AJAX 請求回調函式</li><li>生命週期回調函式</li></ul><h3 id="用函式控制執行函式的時機"><a href="#用函式控制執行函式的時機" class="headerlink" title="用函式控制執行函式的時機"></a>用函式控制執行函式的時機</h3><p>首先我們先用定時器，計 <strong>0 秒</strong>馬上 <code>console</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 A&quot;</span>);<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 B&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 C，最後一個函式&quot;</span>);<br>&#125;<br><br>A();<br>B();<br>C();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;我是函式 B&quot;</span><br><span class="hljs-comment">  &quot;我是函式 C，最後一個函式&quot;</span><br><span class="hljs-comment">  &quot;我是函式 A&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>結果很神奇，沒想到 <strong>0 秒</strong>馬上 <code>console</code> 的函式，竟然最後才出現！<br>那是因為 JavaScript 在遇到<strong>定時器</strong>的時候，會先跳過這段函式，先繼續執行後面的程式碼，在執行定時器（此時已經有毫秒的延遲），這樣的好處當然就是不用苦苦地等<strong>計時器</strong>結束，讓可以先運作的運作完，讓使用者不會有等待的感覺，而這個現象稱作<strong>非同步</strong>！</p><p>而後面的函式又與計時器的這個函式有關的話！就會使用 Callback Function 來處理～</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params">FnB, FnC</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 A&quot;</span>);<br>    FnB( FnC );<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span> (<span class="hljs-params">Fn</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 B&quot;</span>);<br>  Fn();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 C，最後一個函式&quot;</span>);<br>&#125;<br><br>A(B, C);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;我是函式 A&quot;</span><br><span class="hljs-comment">  &quot;我是函式 B&quot;</span><br><span class="hljs-comment">  &quot;我是函式 C，最後一個函式&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>這時在確定執行完 <code>A</code> 後，才會接續執行 <code>B</code> 與 <code>C</code></p><h2 id="回調函式的優缺點"><a href="#回調函式的優缺點" class="headerlink" title="回調函式的優缺點"></a>回調函式的優缺點</h2><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ul><li>能夠確保執行的時機</li><li>更好維護</li></ul><p>例如要添加 D 函式就可以直接使用參數帶入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params">FnB, FnC</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 A&quot;</span>);<br>    FnB( FnC );<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span> (<span class="hljs-params">Fn</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 B&quot;</span>);<br>  Fn();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 C，最後一個函式&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span> (<span class="hljs-params">Fn</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是函式 D&quot;</span>)<br>  Fn;<br>&#125;<br><br>D( A(B, C));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;我是函式 D&quot;</span><br><span class="hljs-comment">  &quot;我是函式 A&quot;</span><br><span class="hljs-comment">  &quot;我是函式 B&quot;</span><br><span class="hljs-comment">  &quot;我是函式 C，最後一個函式&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>相信學程式到一定程度的人，多少都有聽過宛如波動拳的 Callback Hell 吧！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, fnA, fnB, fnC, fnD, fnE</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (fnA(n)) &#123;<br>        <span class="hljs-keyword">if</span> (fnB(n)) &#123;<br>            <span class="hljs-keyword">if</span> (fnC(n)) &#123;<br>                <span class="hljs-keyword">if</span> (fnD(n)) &#123;<br>                    <span class="hljs-keyword">if</span> (fnE(n)) &#123;<br>                      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fnE&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fnD&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fnC&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fnB&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fnA&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>回調函式（Callback Function）是個很常見的寫法，但要小心使用，使用不當後續會很痛苦，而後面又有推出 <code>Promise</code> 與 <code>Async / Await</code> ，就解決了同步與非同步的問題！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li><li><a href="https://medium.com/appxtech/%E4%BB%80%E9%BA%BC%E6%98%AFcallback%E5%87%BD%E5%BC%8F-callback-function-3a0a972d5f82">什麼是 Callback 函式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.24 「你點了按鈕～同時也點了網頁本身！」 —— JavaScript 事件冒泡（Event bubbling）</title>
    <link href="/2021/10/03/2021-10-3-it_ironman-day24/"/>
    <url>/2021/10/03/2021-10-3-it_ironman-day24/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-24-「你點了按鈕～同時也點了網頁本身！」-——-JavaScript-事件冒泡（Event-bubbling）"><a href="#Day-24-「你點了按鈕～同時也點了網頁本身！」-——-JavaScript-事件冒泡（Event-bubbling）" class="headerlink" title="Day.24 「你點了按鈕～同時也點了網頁本身！」 —— JavaScript 事件冒泡（Event bubbling）"></a>Day.24 「你點了按鈕～同時也點了網頁本身！」 —— JavaScript 事件冒泡（Event bubbling）</h1><p><img src="https://i.imgur.com/oHkbDov.png" alt="「你點了按鈕～同時也點了網頁本身！」 —— JavaScript 事件冒泡（Event bubbling）"></p><p>我們上一個篇章認識了綁定事件，了解到不管是什麼節點，都可以綁定事件</p><p>那為什麼 JavaScript 會知道我們觸發事件？</p><h2 id="事件觸發流程"><a href="#事件觸發流程" class="headerlink" title="事件觸發流程"></a>事件觸發流程</h2><p>當我們點擊網頁中任何一個元素，是不是也等於點擊到網頁本身！<br>而點擊元素與網頁本身這個過程是有順序的，稱為<strong>事件流程</strong>，事件流程共有兩個機制：</p><ul><li>事件捕獲</li><li>事件冒泡</li></ul><h3 id="事件捕獲（Event-Capturing）"><a href="#事件捕獲（Event-Capturing）" class="headerlink" title="事件捕獲（Event Capturing）"></a>事件捕獲（Event Capturing）</h3><p><img src="https://i.imgur.com/VOku3FJ.png" alt="事件捕獲"></p><p>當我們點擊藍色的 <code>div</code> 時，網頁會從根目錄開始往下找到我們點擊的元素，這個過程稱為<strong>事件捕獲</strong></p><h3 id="事件冒泡（Event-Bubbling）"><a href="#事件冒泡（Event-Bubbling）" class="headerlink" title="事件冒泡（Event Bubbling）"></a>事件冒泡（Event Bubbling）</h3><p>而事件冒泡則剛好反過來！</p><p><img src="https://i.imgur.com/6cvkX39.png" alt="事件冒泡"></p><p>當我們點擊藍色的 <code>div</code> 時，會從我們點擊的元素往上傳遞到根目錄，這個過程稱為<strong>事件捕獲</strong></p><p>而如何確認冒泡的情況是否發生？</p><p>就把每個元素都綁上 <code>onclick</code> 點擊事件，連 <code>body</code> 也綁定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box parent red&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box child green&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box child blue&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 綁定元素</span><br><span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.body;<br><span class="hljs-keyword">const</span> red = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;red&quot;</span>);<br><span class="hljs-keyword">const</span> green = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;green&quot;</span>);<br><span class="hljs-keyword">const</span> blue = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;blue&quot;</span>);<br><br><br><span class="hljs-comment">// 綁定監聽</span><br>body.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m body&quot;</span>);<br>&#125;<br>red.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m parent red&quot;</span>);<br>&#125;<br>green.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m child green&quot;</span>);<br>&#125;<br>blue.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m child blue&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>這時點擊藍色 <code>div</code> 就會觸發事件冒泡，會看到先出現藍色依序往根標籤傳遞，而因為沒點擊綠色，所以綠色不會觸發！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;I&#x27;m child blue&quot;</span><br><span class="hljs-string">&quot;I&#x27;m parent red&quot;</span><br><span class="hljs-string">&quot;I&#x27;m body&quot;</span><br></code></pre></td></tr></table></figure><p>在大部分情況下，冒泡事件都是有用的，例如：拖曳功能，如果不希望冒泡事件觸發，可以針對觸發事件元素取消冒泡事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">blue.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>  event = event || <span class="hljs-built_in">window</span>.event;  <span class="hljs-comment">// 避免找不到 event</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m child blue&quot;</span>);<br>  <br>  event.cancelBubble = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 取消冒泡事件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>這樣點擊就只會觸發藍色的事件，不會往上觸發了！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這也是 JavaScript 經常會接觸到的事件，只是平常我們都會需要冒泡事件，只有特定時候才會取消冒泡，算是前端基礎面試題</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.23 「更加認識 DOM，並初次了解事件綁定」 —— JavaScript DOM</title>
    <link href="/2021/10/02/2021-10-2-it_ironman-day23/"/>
    <url>/2021/10/02/2021-10-2-it_ironman-day23/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-23-「更加認識-DOM，並初次了解事件綁定」-——-JavaScript-DOM"><a href="#Day-23-「更加認識-DOM，並初次了解事件綁定」-——-JavaScript-DOM" class="headerlink" title="Day.23 「更加認識 DOM，並初次了解事件綁定」 —— JavaScript DOM"></a>Day.23 「更加認識 DOM，並初次了解事件綁定」 —— JavaScript DOM</h1><p><img src="https://i.imgur.com/slZvdj6.png" alt="「更加認識 DOM，並初次了解事件綁定」 —— JavaScript DOM"></p><p>我們之前在 HTML 篇章有介紹 DOM，是 Document Object Model 的縮寫！<br>我們主要操作 DOM 來控制網頁內容</p><ul><li>Document 代表了<strong>整個 HTML 網頁</strong></li><li>Object 代表把網頁中每個部分節點都轉變成<strong>物件</strong></li><li>Model 代表用來表示物件之間的關係，形成容易理解的樹狀圖，也就是 <strong>DOM Tree</strong></li></ul><p><img src="https://i.imgur.com/zWx3NJn.png" alt="DOM tree"></p><p>還記得它吧～</p><h2 id="利用-DOM-取得文本內容"><a href="#利用-DOM-取得文本內容" class="headerlink" title="利用 DOM 取得文本內容"></a>利用 DOM 取得文本內容</h2><p>之前已經認識了網頁標籤，而現在我們要透過 JavaScript 來獲取我們的網頁節點！<br>假設我們要獲取 <code>button</code> 內的文本內容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="獲取文本內容"><a href="#獲取文本內容" class="headerlink" title="獲取文本內容"></a>獲取文本內容</h3><ul><li>可以使用 <code>textContent</code> 來獲取文本內容<strong>字</strong>的部分，同時也能依靠它來變更文本內容</li><li>可以使用 <code>innerHTML</code> 來獲取文本內容，與 <code>textContent</code> 相比更方便常用，除了獲取到文本內容的字，連文本內容的標籤也會獲取，同時也能依靠它來變更文本內容與標籤</li></ul><h3 id="獲取節點"><a href="#獲取節點" class="headerlink" title="獲取節點"></a>獲取節點</h3><p>而獲取節點的方法也很多，我來講幾個比較常用的獲取方法～</p><ul><li>透過 <code>id</code> 來獲取 <code>document.getElementById(&quot;&quot;);</code>，因為 <code>id</code> 單一的特性，所以只會獲取到一個節點</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);<br><span class="hljs-built_in">console</span>.log( btn.innerHTML );  <span class="hljs-comment">// &quot;我是按鈕&quot;</span><br></code></pre></td></tr></table></figure><ul><li>透過 元素節點 來獲取 <code>document.getElementsByTagName(&quot;&quot;);</code> ，需注意因為 元素節點 是<strong>複數</strong>，所以會獲得一個類似陣列的<strong>物件</strong>，並以索引值代表順序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-built_in">console</span>.log( btn[<span class="hljs-number">0</span>].innerHTML );  <span class="hljs-comment">// &quot;我是按鈕&quot;</span><br></code></pre></td></tr></table></figure><ul><li>透過 <code>class</code> 來獲取 <code>document.getElementsByClassName(&quot;&quot;);</code> ，需注意 <code>class</code> 選擇器是<strong>複數</strong>，所以會獲得一個類似陣列的<strong>物件</strong>，並以索引值代表順序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;btn&quot;</span>);<br><span class="hljs-built_in">console</span>.log( btn[<span class="hljs-number">0</span>].innerHTML );  <span class="hljs-comment">// &quot;我是按鈕&quot;</span><br></code></pre></td></tr></table></figure><ul><li>與 jQuery 一樣方便的節點選擇器 <code>document.querySelector(&quot;&quot;)</code> 和 <code>document.querySelectorAll(&quot;&quot;)</code>，前面的是只會<strong>回傳第一個</strong>，後面的是只要符合條件的<strong>都會回傳</strong>，而這個回傳的是比較像陣列的 <strong>NodeList</strong>。<strong>需注意</strong> 的是，它的條件可以是 元素、<code>id</code>、<code>class</code>，所以跟 CSS 選擇器一樣，元素不需要前贅詞，<code>id</code> 需要前贅詞 <code>#</code>，<code>class</code> 需要前贅詞 <code>.</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;#btn&quot;</span>);<br><span class="hljs-built_in">console</span>.log( btn.innerHTML );  <span class="hljs-comment">// &quot;我是按鈕&quot;</span><br><span class="hljs-keyword">const</span> btnAll = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-built_in">console</span>.log( btnAll[<span class="hljs-number">0</span>].innerHTML );  <span class="hljs-comment">// &quot;我是按鈕&quot;</span><br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是使用者與瀏覽器互動的行為，如：點擊按鈕、滑鼠移動、控制視窗…等</p><p>我們可以事先在網頁內寫好 JavaScript 程式碼，當這些事件觸發時，就會執行程式碼，這也就是 JavaScript 負責互動的部分！</p><p>同樣的事件綁定也有很多種方法</p><h3 id="寫在-HTML-內"><a href="#寫在-HTML-內" class="headerlink" title="寫在 HTML 內"></a>寫在 HTML 內</h3><p>這方法其實不太好，因為 <strong>HTML 結構</strong>與 <strong>JavaScript 行為</strong>牽連在一起，會比較不方便維護，但還是認識一下！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&quot;</span>你點到按鈕了！&quot;);&quot;&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!--  這樣點擊按鈕就會跳出視窗顯示「你點到按鈕了！」  --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="綁定事件"><a href="#綁定事件" class="headerlink" title="綁定事件"></a>綁定事件</h3><p>這是常用的方法，結構與行為分開</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>獲取到節點後綁定 <code>onclick</code> 點擊事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);  <span class="hljs-comment">// 獲取 btn 節點</span><br><span class="hljs-comment">/*  綁定 onclick 事件  */</span><br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&quot;你又點到按鈕了！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="瀏覽器執行順序"><a href="#瀏覽器執行順序" class="headerlink" title="瀏覽器執行順序"></a>瀏覽器執行順序</h2><p>之前第二天有介紹 <code>script</code> 標籤通常都放在最下面，而不會放在 <code>head</code> 標籤內，是因為瀏覽器在執行的時候，是<strong>由上而下</strong>執行下來。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(btn);  <span class="hljs-comment">// null</span></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>這時 <code>btn</code> 獲取到的物件節點就會回傳 <code>null</code>，因為它找不到節點！</p><p>而寫在下面 <code>&lt;/body&gt;</code> 標籤前時</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(btn);  <span class="hljs-comment">// &lt;button id=&quot;btn&quot;&gt;我是按鈕&lt;/button&gt;</span></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就能正常回傳 <code>&lt;button id=&quot;btn&quot;&gt;我是按鈕&lt;/button&gt;</code> 節點了</p><h3 id="onload-事件"><a href="#onload-事件" class="headerlink" title="onload 事件"></a>onload 事件</h3><p>如果我一定要寫在上面呢？其實可以使用 <code>onload</code> 事件綁定，等<strong>網頁畫面執行完（DOM 已經完成）</strong>了，才執行程式碼</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-comment">/*  事件綁定在 window 上  */</span></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      </span><br><span class="javascript">        <span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(btn);  <span class="hljs-comment">// &lt;button id=&quot;btn&quot;&gt;我是按鈕&lt;/button&gt;</span></span><br><span class="javascript">        </span><br><span class="javascript">      &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按鈕<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>終於要開始為我們網頁添加互動元素了！今天的 DOM 對於互動頁面非常重要，而我們還有 BOM 還沒介紹！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.22 「讓我們在更深入函式～」 —— JavaScript call &amp; apply &amp; arguments</title>
    <link href="/2021/10/01/2021-10-1-it_ironman-day22/"/>
    <url>/2021/10/01/2021-10-1-it_ironman-day22/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-22-「讓我們在更深入函式～」-——-JavaScript-call-amp-apply-amp-arguments"><a href="#Day-22-「讓我們在更深入函式～」-——-JavaScript-call-amp-apply-amp-arguments" class="headerlink" title="Day.22 「讓我們在更深入函式～」 —— JavaScript call &amp; apply &amp; arguments"></a>Day.22 「讓我們在更深入函式～」 —— JavaScript call &amp; apply &amp; arguments</h1><p><img src="https://i.imgur.com/ejWtzFz.png" alt="「讓我們在更深入函式～」 —— JavaScript call &amp; apply &amp; arguments"></p><p>之前我們有說過，再調用函式的時候，瀏覽器會傳遞隱藏的參數給我們函式<br>一個是「this」，除了 this 還有另一個參數是「arguments」！</p><p>我們都知道全域函式直接調用的話，this 會指向 <code>window</code>。<br>但其實函式有方法給我們綁定 JavaScript 中的「this」</p><h2 id="Arrow-function"><a href="#Arrow-function" class="headerlink" title="Arrow function"></a>Arrow function</h2><p>這是 ES6 新增的函式，叫做「箭頭函式表達式」，看到表達式就知道可以直接賦值。<br>用法其實跟用宣告的函式很像！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> normal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <span class="hljs-comment">// 普通宣告函式</span><br><span class="hljs-keyword">const</span> echo = <span class="hljs-function">() =&gt;</span> &#123;&#125;        <span class="hljs-comment">// 箭頭函式</span><br></code></pre></td></tr></table></figure><p>箭頭函式的優點</p><ul><li>更簡短的函式寫法</li><li>this 變數強制綁定</li></ul><p>以加法為例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> plus = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-built_in">console</span>.log( plus(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) );  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>當執行程式碼只有一行時，可以<strong>省略</strong>大括號與 <code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> plus = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-built_in">console</span>.log( plus(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) );  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>是不是覺得很精簡，跟魔法一樣！</p><h2 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h2><p>平常直接調用函式，this 的指向會朝 window 這個物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span> );  <br>&#125;<br><br>echo() <span class="hljs-comment">// window</span><br></code></pre></td></tr></table></figure><p>但當我們利用 <code>call()</code> 或 <code>apply()</code> 方法，第一個參數設為物件，就可以把 this 指向該物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>echo.call(obj);    <span class="hljs-comment">// &#123;&#125;</span><br>echo.apply(obj);   <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>除了第一個要傳遞物件外，也能正常的傳遞參數，只是傳遞參數的型別不太一樣。</p><ul><li><code>call</code>，第一個參數為 this 指向，後面參數正常帶入就可以了</li><li><code>apply</code>，第一個參數為 this 指向，第二個參數必須使用陣列，參數放在<strong>陣列內</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b = &quot;</span>+ b);<br>&#125;<br><br>echo.call(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;我是 b&#x27;</span>);    <span class="hljs-comment">// &quot;a = 1&quot; &quot;b = 我是 b&quot; </span><br>echo.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;我是 b&#x27;</span>]); <span class="hljs-comment">// &quot;a = 1&quot; &quot;b = 我是 b&quot; </span><br></code></pre></td></tr></table></figure><h2 id="判斷-this-的情況"><a href="#判斷-this-的情況" class="headerlink" title="判斷 this 的情況"></a>判斷 this 的情況</h2><p>加上之前所認識的，我們更加能掌控我們的 this 了</p><ul><li>以函式<strong>直接調用</strong>的 this 會指向 window</li><li>以<strong>物件方法</strong>的方式調用，this 會指向該物件</li><li>以<strong>構造函式</strong>的方式調用，this 會指向新增的物件</li><li>使用 <code>call</code> 或 <code>apply</code> 方法調用時，this 會指向指定的物件</li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>如何知道有這個參數，很簡單，直接 <code>console.log()</code> 看看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>&#125;<br><br>echo();  <span class="hljs-comment">// Argument &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>argument 是一個類似陣列的<strong>物件</strong>，會把我們函式內的參數傳遞到 arguments 裡面保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;參數有 &quot;</span>+ <span class="hljs-built_in">arguments</span>.length +<span class="hljs-string">&quot;個&quot;</span>);<br>&#125;<br><br>echo(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// &#123; 0: &quot;a&quot;, 1: 1 &#125;  &quot;參數有 2 個&quot;</span><br></code></pre></td></tr></table></figure><p>這樣即使我們函式本身不使用參數，也能透過物件取值的方式 <code>argument[index]</code> 來獲取參數</p><p>很常使用在參數不確定有幾個的時候。</p><p>像是把函式內的參數總和取平均值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">average</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>    total += +<span class="hljs-built_in">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(total / <span class="hljs-built_in">arguments</span>.length);<br>&#125;<br><br>average(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>也能使用 <code>callee</code> 來獲取執行的<strong>函式本身</strong>，在配合匿名立即執行函式使用時非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.callee);<br>&#125;)();  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  function() &#123;</span><br><span class="hljs-comment">    console.log(arguments.callee);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天又更認識函式的操作方法了，函式是 JavaScript 的精隨之一，也更了解如何操控 this 了～</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.21 「物件也有繼承問題？」 —— JavaScript 繼承 與 原型鍊</title>
    <link href="/2021/09/30/2021-9-30-it-ironman-day21/"/>
    <url>/2021/09/30/2021-9-30-it-ironman-day21/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-21-「物件也有繼承問題？」-——-JavaScript-繼承-與-原型鍊"><a href="#Day-21-「物件也有繼承問題？」-——-JavaScript-繼承-與-原型鍊" class="headerlink" title="Day.21 「物件也有繼承問題？」 —— JavaScript 繼承 與 原型鍊"></a>Day.21 「物件也有繼承問題？」 —— JavaScript 繼承 與 原型鍊</h1><p><img src="https://i.imgur.com/k1U1ZAE.png" alt="「物件也有繼承問題？」 —— JavaScript 繼承 與 原型鍊"></p><p>我們每新增一個函式，瀏覽器都會向函式內新增一個屬性叫 <code>prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-built_in">console</span>.log( Person.prototype );<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/LYfSQkU.png" alt="prototype"></p><h2 id="原型鍊"><a href="#原型鍊" class="headerlink" title="原型鍊"></a>原型鍊</h2><p>如果是普通函式的直接調用，<code>prototype</code> 不會有任何作用</p><p>當是以構造函式的方式調用，他所新增的物件會有一個隱藏的屬性，指向該構造函式的原型物件。<br>雖然 <code>prototype</code> 是隱藏屬性，但我們可以透過 <code>__proto__</code> 來查看該屬性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person;<br><span class="hljs-built_in">console</span>.log( person.__proto__ );<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/L81kh1u.png" alt="__proto__"><br><img src="https://i.imgur.com/BEzzYiZ.png" alt="原型鍊"></p><p>也能發現 <code>prototype</code> 與 <code>__proto__</code> 是一樣的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person;<br><span class="hljs-built_in">console</span>.log( Person.prototype === person.__proto__ ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="繼承"><a href="#繼承" class="headerlink" title="繼承"></a>繼承</h2><p>依照之前物件傳址的特性，可以了解到物件中，<strong>共用的內容</strong>，可以設置到 <code>prototype</code> 中，新增的屬性就會<strong>繼承</strong>原型物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>Person.prototype.a = <span class="hljs-string">&quot;我是原型物件 a&quot;</span>;  <span class="hljs-comment">// 添加原型物件屬性 a</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person;<br><span class="hljs-built_in">console</span>.log( person.a );  <span class="hljs-comment">// &quot;我是原型物件 a&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Bxdt1bV.png" alt="繼承原型物件 a 屬性"></p><p>可以發現如果物件內沒有 <code>a</code> 屬性，它就會往原型物件中尋找 <code>a</code> 屬性，如果找到就會使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>Person.prototype.a = <span class="hljs-string">&quot;我是原型物件 a&quot;</span>;  <span class="hljs-comment">// 添加原型物件屬性 a</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person;<br>person.a = <span class="hljs-string">&quot;我是 person 中的 a&quot;</span>;<br><span class="hljs-built_in">console</span>.log( person.a );  <span class="hljs-comment">// &quot;我是 person 中的 a&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/pmDy3um.png" alt="從本身尋找 a 屬性"></p><h3 id="優化之前的-sayName"><a href="#優化之前的-sayName" class="headerlink" title="優化之前的 sayName"></a>優化之前的 <code>sayName</code></h3><p>看到這裡是不是又發現可以更好優化自訂物件的方法了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>person.sayName();  <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br></code></pre></td></tr></table></figure><p>就往原型物件尋找 <code>sayName</code> 方法，同時也不會汙染到我們的全局作用域！</p><h2 id="檢查物件屬性"><a href="#檢查物件屬性" class="headerlink" title="檢查物件屬性"></a>檢查物件屬性</h2><p>有時候，我們會需要檢查物件內有沒有該屬性，可以使用 <code>in</code> 語法來檢查：<code>&quot;屬性名&quot; in 物件名</code>，需注意屬性名要用引號包起來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> person);    <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sayName&quot;</span> <span class="hljs-keyword">in</span> person); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但會發現，會連<strong>原型物件</strong>的屬性也判定為 <code>true</code>，<br>這時如果我們要更確實的判斷是不是該<strong>物件內</strong>的屬性，可以使用 <code>hasOwnProperty()</code> 語法來檢查 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person.hasOwnProperty(<span class="hljs-string">&quot;name&quot;</span>));    <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( person.hasOwnProperty(<span class="hljs-string">&quot;sayName&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="這些「方法」都哪來的"><a href="#這些「方法」都哪來的" class="headerlink" title="這些「方法」都哪來的"></a>這些「方法」都哪來的</h3><p>沒錯！聰明的你應該已經更瞭解<strong>繼承</strong>與<strong>原型鍊</strong>，而我們常用的方法，其實都是在原型物件裡面！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br><br><span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;hasOwnProperty&quot;</span> <span class="hljs-keyword">in</span> person);              <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( person.hasOwnProperty(<span class="hljs-string">&quot;hasOwnProperty&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>這時嘗試使用 <code>__proto__</code> 找出原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br><br><span class="hljs-built_in">console</span>.log( person.__proto__.hasOwnProperty(<span class="hljs-string">&quot;hasOwnProperty&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="原型物件中還有原型物件"><a href="#原型物件中還有原型物件" class="headerlink" title="原型物件中還有原型物件"></a>原型物件中還有原型物件</h4><p>你會發現，奇怪！怎麼還是 <code>false</code>，那是因為，原型物件也是<strong>物件</strong>，原型物件中還有原型物件！<br>當然！這不是無限套娃～會一路找到原型物件為 <code>null</code> 的值，代表該物件沒有原型物件了，而這個物件就是 Object 物件的<strong>原型</strong>！</p><p><img src="https://i.imgur.com/3xgR9DK.png" alt="原型物件中還有原型物件"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br><br><span class="hljs-built_in">console</span>.log( person.__proto__.__proto__);           <span class="hljs-comment">// Object</span><br><span class="hljs-built_in">console</span>.log( person.__proto__.__proto__.__proto__); <span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log( person.__proto__.__proto__.hasOwnProperty(<span class="hljs-string">&quot;hasOwnProperty&quot;</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>已經把我們的物件精隨學習的差不多了～也認識 JavaScript 中，我們常用的方法都藏在物件的隱藏屬性之中！</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.20 「初步認識 this，中央工廠式的自訂物件～」 —— JavaSript 構造函式</title>
    <link href="/2021/09/29/2021-9-29-it_ironman-day20/"/>
    <url>/2021/09/29/2021-9-29-it_ironman-day20/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-20-「初步認識-this，中央工廠式的自訂物件～」-——-JavaSript-構造函式"><a href="#Day-20-「初步認識-this，中央工廠式的自訂物件～」-——-JavaSript-構造函式" class="headerlink" title="Day.20 「初步認識 this，中央工廠式的自訂物件～」 —— JavaSript 構造函式"></a>Day.20 「初步認識 this，中央工廠式的自訂物件～」 —— JavaSript 構造函式</h1><p><img src="https://i.imgur.com/MowXDC1.png" alt="Day.20 「初步認識 this，中央工廠式的自訂物件～」 —— JavaSript 構造函式"></p><p>如同<strong>學習函式</strong>一樣！有時候我們會一直重複地做一件事，<br>當還是初學者的我們需要製作大量的個人資料物件時，通常第一個想法就是複製貼上～</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + person.name );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小黃&quot;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + person2.name );<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* ... */</span><br></code></pre></td></tr></table></figure><p>一直重複製作一樣的東西！<br>我們要發揮工程師的精神～看到一直有重複的程式碼時，就要想辦法簡化它。<br>在學習自訂物件之前，要先認識之前函式沒說到的「<strong>this</strong>」</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>瀏覽器在執行函式時，都會向函式傳遞一個<strong>隱藏的參數</strong>！</p><ul><li><p>這個隱藏的參數就是今天的主角「this」，this 指向的是一個<strong>物件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;<br>echo ();  <span class="hljs-comment">// this 指向 window 這個物件</span><br></code></pre></td></tr></table></figure></li><li><p>隨著函式<strong>執行的場合不同</strong>，this 的指向也會不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoName</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><span class="hljs-comment">// 為 window 這個物件添加 name 屬性，也就是在全局作用域宣告 name 變數</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;我是 window 的 name 屬性&quot;</span>;  <br><br>echoName ();  <span class="hljs-comment">// &quot;我是 window 的 name 屬性&quot;</span><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: echoName  <span class="hljs-comment">// 物件添加函式</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(obj.sayName === echoName);  <span class="hljs-comment">// true 用來確認是不是同一個函式</span><br><br>obj.sayName();  <span class="hljs-comment">// &quot;毛毛&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>根據執行的場合不同，指向不同懶人包</p><ul><li>直接調用函式，this 的指向永遠在 <strong>window</strong></li><li>使用物件的函式，this 的指向會在使用的<strong>那個物件</strong></li><li>使用建構函式，this 會指向<strong>新增建構函式的物件</strong></li></ul></li></ul><p>當然這只是稍微認識了我們的 this，不過以目前的知識量，就能夠的自訂物件了！</p><h2 id="利用函式新增物件"><a href="#利用函式新增物件" class="headerlink" title="利用函式新增物件"></a>利用函式新增物件</h2><p>我們前面有說過，函式非常方便，可以把功能都寫在函式裡，例如我們現在要來自定義物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;  <span class="hljs-comment">// 新增一個物件</span><br>  obj.name = <span class="hljs-string">&quot;毛毛&quot;</span>,<br>  obj.gender = <span class="hljs-string">&quot;男&quot;</span>,<br>  obj.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">const</span> person = createPerson();<br><span class="hljs-built_in">console</span>.log( person );<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   &#123;</span><br><span class="hljs-comment">      name: &quot;毛毛&quot;,</span><br><span class="hljs-comment">      gender: &quot;男&quot;,</span><br><span class="hljs-comment">      sayName: function() &#123;</span><br><span class="hljs-comment">        console.log( &quot;大家好！我是&quot; + this.name );</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>但會發現這樣新增的物件的是固定的！<br>這時我們利用函式的<strong>參數</strong>，就可以簡化新增物件的步驟了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;  <span class="hljs-comment">// 新增一個物件</span><br>  obj.name = name,<br>  obj.gender = gender,<br>  obj.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">const</span> person = createPerson(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-keyword">const</span> person2 = createPerson(<span class="hljs-string">&quot;小黃&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>person.sayName();  <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br>person2.sayName();  <span class="hljs-comment">// &quot;大家好！我是小黃&quot;</span><br></code></pre></td></tr></table></figure><p>但如果這個時候～還想要自訂一個寵物的物件，這樣直接看會覺得 人的物件 與 寵物的物件 差不多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPet</span> (<span class="hljs-params">name, sex, animal</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;  <span class="hljs-comment">// 新增一個物件</span><br>  obj.name = name,<br>  obj.sex = sex,<br>  obj.animal = animal<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">const</span> pet = createPet(<span class="hljs-string">&quot;小黃&quot;</span>, <span class="hljs-string">&quot;雄性&quot;</span>, <span class="hljs-string">&quot;小狗&quot;</span>);<br><span class="hljs-built_in">console</span>.log( pet );   <span class="hljs-comment">// &#123;...&#125;</span><br><span class="hljs-built_in">console</span>.log( person ) <span class="hljs-comment">// &#123;...&#125; </span><br></code></pre></td></tr></table></figure><p>這時使用建構函式來真正意義上的自訂物件，更加方便快速簡單！</p><h2 id="構造函式"><a href="#構造函式" class="headerlink" title="構造函式"></a>構造函式</h2><p>自訂一個構造函式，用來專門新增人的物件</p><ul><li>構造函式就是一個普通函式，新增的方法與普通的方法沒有不同</li><li>不同的是建構函式會習慣在<strong>首字母大寫</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>普通函式是直接調用，而構造函式是透過 <code>new</code> 關鍵字調用！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> 直接調用 = Person()<br><span class="hljs-keyword">const</span> 構造函式 = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log( 直接調用 );  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log( 構造函式 );  <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>直接調用的函式，因為沒有使用 <code>return</code> ，所以會自動返回 <code>undefined</code></p><h3 id="構造函式執行過程"><a href="#構造函式執行過程" class="headerlink" title="構造函式執行過程"></a>構造函式執行過程</h3><ol><li>會立刻自動新增一個物件</li><li>函式的 <strong>this 會指向該物件</strong></li><li>逐行執行程式碼（我們操作的部分）</li><li>將新增的物件作為返回值返回</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender,<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person )  <span class="hljs-comment">// Person &#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>這時你發現前面出現了 <code>Person</code>，再來用一個的寵物的構造函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pet</span> (<span class="hljs-params">name, sex, animal</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.sex = sex,<br>  <span class="hljs-built_in">this</span>.animal = animal<br>&#125;<br><span class="hljs-keyword">const</span> pet = <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;小黃&quot;</span>, <span class="hljs-string">&quot;雄性&quot;</span>, <span class="hljs-string">&quot;小狗&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person )  <span class="hljs-comment">// Person &#123;...&#125;</span><br><span class="hljs-built_in">console</span>.log( pet )     <span class="hljs-comment">// Pet &#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>這樣就可以透過構造函式更直觀的看<strong>同一類的物件</strong>！</p><h3 id="構造函式實例檢查"><a href="#構造函式實例檢查" class="headerlink" title="構造函式實例檢查"></a>構造函式實例檢查</h3><p>JavaScript 有個語法 <code>instanceof</code>，可以用來檢查，物件是否為該構造函式新增出來的實例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(person <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true  代表是由這個構造函式創建出來的</span><br><span class="hljs-built_in">console</span>.log(person <span class="hljs-keyword">instanceof</span> Pet);    <span class="hljs-comment">// false 代表不是由這個構造函式創建出來的</span><br></code></pre></td></tr></table></figure><h2 id="優化構造函式"><a href="#優化構造函式" class="headerlink" title="優化構造函式"></a>優化構造函式</h2><p>我們前面的構造函式中，有為物件添加函式 <code>sayName()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender,<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>person.sayName();  <span class="hljs-comment">// &quot;大家好！我是毛毛&quot;</span><br></code></pre></td></tr></table></figure><p>而我們每新增一個物件，同時也跟著在物件內<strong>新增</strong>一個 <code>sayName</code> 函式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender,<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小黃&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person.sayName === person2.sayName );  <span class="hljs-comment">// false  兩個 sayName 不一樣</span><br></code></pre></td></tr></table></figure><p>發現 <code>sayName</code> 函式，彼此不相同，當新增了 10000 個 Person 物件，也會同時新增 10000 個 <code>sayName</code> 函式！而這 10000 個 <code>sayName</code> 函式其實都是一模一樣的，會為了這一模一樣的函式浪費記憶體空間！</p><p>這想當然是沒有必要的事情，我們可以讓所有物件共同使用一個函式。<br>直接在全局作用域定義一個 <code>sayName</code> 函式，在構造函式內賦值 <code>sayName</code> 函式，這時構造函式內找不到 <code>sayName</code> 函式，就會往外找 <code>sayName</code> 函式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name,<br>  <span class="hljs-built_in">this</span>.gender = gender,<br>  <span class="hljs-built_in">this</span>.sayName = sayName<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;大家好！我是&quot;</span> + <span class="hljs-built_in">this</span>.name );<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小黃&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person.sayName === person2.sayName );  <span class="hljs-comment">// true  兩個 sayName 引用同一個函式，所以一樣</span><br></code></pre></td></tr></table></figure><p>當然這樣也是有缺點，就是把函式定義在全局作用域會壓縮到全局作用域的命名空間，而且多人協作的時候，也容易出問題</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天稍微介紹了 JavaScript 的 「this」，它可是 JavaScript 的精隨，少了 <code>this</code> 會有很多事情不能做，昨天介紹的記憶體堆疊，在使用物件型別的東西要特別注意，不然一不小心會讓瀏覽器效能變低，網頁卡卡的！</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.19 「認識 JavaScript 記憶體堆疊、傳值 與 傳址」 —— JavaScript 物件 與 記憶體</title>
    <link href="/2021/09/28/2021-9-28-it_ironman-day19/"/>
    <url>/2021/09/28/2021-9-28-it_ironman-day19/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-19-「認識-JavaScript-記憶體堆疊、傳值-與-傳址」-——-JavaScript-物件-與-記憶體"><a href="#Day-19-「認識-JavaScript-記憶體堆疊、傳值-與-傳址」-——-JavaScript-物件-與-記憶體" class="headerlink" title="Day.19 「認識 JavaScript 記憶體堆疊、傳值 與 傳址」 —— JavaScript 物件 與 記憶體"></a>Day.19 「認識 JavaScript 記憶體堆疊、傳值 與 傳址」 —— JavaScript 物件 與 記憶體</h1><p><img src="https://i.imgur.com/PQ6GCWn.png" alt="「認識 JavaScript 記憶體堆疊、傳值 與 傳址」 —— JavaScript 物件 與 記憶體"></p><p>我們的變數在我們開啟網站時，都會存放在記憶體內，當我們關閉網站時，記憶體也會將這些變數釋放。</p><h2 id="記憶體的堆疊"><a href="#記憶體的堆疊" class="headerlink" title="記憶體的堆疊"></a>記憶體的堆疊</h2><p>JavaScript 變數都是保存在 Stack 中</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>而基本型別的值會直接儲存在 Stack 中，值與值之間獨立存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = a;  <span class="hljs-comment">// b = 1</span><br>a++;        <span class="hljs-comment">// a = 2</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b);  <span class="hljs-comment">// &quot;a = 2, b = 1&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2H1GS2f.png" alt="Stack 示意圖"></p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>物件型別的<strong>值</strong>會保存在 Heap 中<br>每新增一個新物件（new Object），都會在 Heap 中開闢一個新空間。<br>而物件變數<strong>保存</strong>的會是指向新空間的<strong>地址</strong>（物件的引用複製），<br>如果新變數<strong>複製</strong>的是同一個物件，當一個<strong>物件屬性修改</strong>，另一個也會受到影響！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;   <span class="hljs-comment">// 開闢新地址</span><br>obj.name = <span class="hljs-string">&quot;毛毛&quot;</span>;       <span class="hljs-comment">// &#123; name: &quot;毛毛&quot; &#125;</span><br><span class="hljs-keyword">var</span> obj2 = obj;         <span class="hljs-comment">// 複製地址</span><br>obj2.name = <span class="hljs-string">&quot;鮭魚&quot;</span>;      <span class="hljs-comment">// 更改 obj2 &#123; name: &quot;鮭魚&quot; &#125;</span><br><span class="hljs-built_in">console</span>.log( obj.name );<span class="hljs-comment">// 因為參考地址一樣，obj 也被修改 &#123; name: &quot;鮭魚&quot; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/7kEpVvp.png" alt="Heap 示意圖"></p><h2 id="傳值（Pass-by-value）"><a href="#傳值（Pass-by-value）" class="headerlink" title="傳值（Pass by value）"></a>傳值（Pass by value）</h2><p>所以根據上面的記憶裡內存，可以瞭解到單純的基本型別存入的就是單純的值。<br>而<strong>基本型別複製</strong>到別的變數，這個過程稱為<strong>傳值</strong>，複製過去後就是<strong>獨立</strong>的變數。<br>而變數的比較就是 <strong>Stack 值</strong>的比較，這比較簡單好懂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log( a === b );  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="傳址（Pass-by-reference）"><a href="#傳址（Pass-by-reference）" class="headerlink" title="傳址（Pass by reference）"></a>傳址（Pass by reference）</h2><p>而比較複雜的物件呢？上面也有看到物件存在 Stack 中的是 Heap 地址。<br>而<strong>物件型別複製</strong>到別的變數，這個過程稱為<strong>傳址</strong>，複製過去後，使用的都是同一個<strong>物件</strong>（地址）<br>而變數的比較是 Stack 值得比較，如果是新增物件的話，Stack 存入的地址會不一樣，所以會回傳 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;        <span class="hljs-comment">// 開闢新物件地址</span><br>obj.name = <span class="hljs-string">&quot;毛毛&quot;</span>;            <span class="hljs-comment">// &#123; name: &quot;毛毛&quot; &#125;</span><br><span class="hljs-keyword">var</span> obj2 = obj;              <span class="hljs-comment">// 直接複製地址引用同個物件 &#123; name: &quot;毛毛&quot; &#125;</span><br><span class="hljs-keyword">var</span> obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span> &#125;;  <span class="hljs-comment">// 開闢新物件地址 &#123; name: &quot;毛毛&quot; &#125;</span><br><span class="hljs-built_in">console</span>.log( obj === obj2 ); <span class="hljs-comment">// true   引用同一個物件</span><br><span class="hljs-built_in">console</span>.log( obj === obj3 ); <span class="hljs-comment">// false  雖然物件看起來一樣，但引用地址不一樣</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/n5yyTMD.png" alt="Pass by reference 示意圖"></p><h2 id="共享（Pass-by-sharing）"><a href="#共享（Pass-by-sharing）" class="headerlink" title="共享（Pass by sharing）"></a>共享（Pass by sharing）</h2><p>來囉！讓人頭昏昏眼花花的概念，物件遇上函式作用域就更加曖昧更加複雜了，上一篇認識了函式中的<strong>函式作用域</strong>，所以我們知道</p><h3 id="當-參數-是-基本型別"><a href="#當-參數-是-基本型別" class="headerlink" title="當 參數 是 基本型別"></a>當 參數 是 基本型別</h3><p>傳<strong>基本型別</strong>的參數，其實就等於在函式作用域宣告<strong>變數</strong>並<strong>傳值</strong>，傳值<strong>獨立</strong>的關係，自然影響不到外面的變數，除非使用 <code>return</code> 回傳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">change</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> c = b;<br>  b = a;<br>  a = c;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;a = &quot;</span>+ a, <span class="hljs-string">&quot;b = &quot;</span>+b);<br>&#125;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;<br>change(x, y);  <span class="hljs-comment">// &quot;a = 2&quot; &quot;b = 1&quot;</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;x = &quot;</span>+ x, <span class="hljs-string">&quot;y = &quot;</span>+ y ); <span class="hljs-comment">// &quot;x = 1&quot; &quot;y = 2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="當-參數-是-物件型別"><a href="#當-參數-是-物件型別" class="headerlink" title="當 參數 是 物件型別"></a>當 參數 是 物件型別</h3><p>傳<strong>物件型別</strong>的參數，就變成在函式作用域宣告變數並<strong>傳址</strong>，傳址因為是引用<strong>同一個物件</strong>，所以對屬性更動時，就會影響到外面的物件變數！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rename</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj.name = <span class="hljs-string">&quot;鮭魚&quot;</span>;  <span class="hljs-comment">// 修改物件內的&quot;屬性&quot;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span> &#125;<br><span class="hljs-built_in">console</span>.log( person.name ); <span class="hljs-comment">// &quot;毛毛&quot;</span><br>rename( person );<br><span class="hljs-built_in">console</span>.log( person.name ); <span class="hljs-comment">// &quot;鮭魚&quot;</span><br></code></pre></td></tr></table></figure><p>沒錯！竟然修改了函式作用域外的東西了，因為指向的是同一個物件！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rename</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj = &#123; name = <span class="hljs-string">&quot;鮭魚&quot;</span> &#125; <span class="hljs-comment">// 在作用域裡面新增物件地址</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;毛毛&quot;</span> &#125;<br><span class="hljs-built_in">console</span>.log( person.name ); <span class="hljs-comment">// &quot;毛毛&quot;</span><br>rename( person );<br><span class="hljs-built_in">console</span>.log( person.name ); <span class="hljs-comment">// &quot;毛毛&quot;</span><br></code></pre></td></tr></table></figure><p>但如果是直接對<strong>整個物件</strong>修改，就會發現作用域外面不會被影響了，因為它等同於<strong>物件實字</strong>新增了一個<strong>新物件地址</strong>，這個值無法傳遞到外面。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上物件可以套用到陣列，這樣我們就認識物件型別與基本型別不同的地方了，有點抽象！<strong>傳值</strong>與<strong>傳址</strong>的概念在寫 JavaScript 邏輯時，<strong>非常重要</strong>，未來在學框架時，這些基礎越扎實，框架就學的越快越輕鬆！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10209104">你不可不知的 JavaScript 二三事</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.18 「從函式物件認識 作用域 與 提升！」 —— JavaScript 函式 &amp; 作用域 &amp; 提升</title>
    <link href="/2021/09/27/2021-9-27-it_ironman-day18/"/>
    <url>/2021/09/27/2021-9-27-it_ironman-day18/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-18-「從函式物件認識-作用域-與-提升！」-——-JavaScript-函式-amp-作用域-amp-提升"><a href="#Day-18-「從函式物件認識-作用域-與-提升！」-——-JavaScript-函式-amp-作用域-amp-提升" class="headerlink" title="Day.18 「從函式物件認識 作用域 與 提升！」 —— JavaScript 函式 &amp; 作用域 &amp; 提升"></a>Day.18 「從函式物件認識 作用域 與 提升！」 —— JavaScript 函式 &amp; 作用域 &amp; 提升</h1><p><img src="https://i.imgur.com/dUL5Ryk.png" alt="「從函式物件認識 作用域 與 提升！」 —— JavaScript 函式 &amp; 作用域 &amp; 提升"></p><p>函數也是個物件型別，可以封裝一些功能（程式碼），在需要使用的時候執行功能（程式碼）。</p><p>例如我們需要把數字相加，在沒有函式的時候，需要用的時候就要重複打程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> result = x + y;<br><span class="hljs-built_in">console</span>.log( result );  <span class="hljs-comment">// 2</span><br>x = <span class="hljs-number">3</span>;<br>y = <span class="hljs-number">2</span>;<br>result = x + y;<br><span class="hljs-built_in">console</span>.log( result );  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>而我們學程式，講求的就是效率，所以自己定義一個函式封裝相加功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = x + y;<br>  <span class="hljs-built_in">console</span>.log( result );<br>&#125;<br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 2</span><br>sum(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h2 id="認識函式結構"><a href="#認識函式結構" class="headerlink" title="認識函式結構"></a>認識函式結構</h2><p><img src="https://i.imgur.com/JFEdr8A.png" alt="函式結構"></p><p>從上面的函式結構我們可以看到</p><ul><li>函式名稱：這其實不一定會有，但我們先介紹基礎的方法，主要用處是在使用函式時需要使用名字來呼喚。</li><li>參數：這不一定要傳，主要是用來傳遞資料給函式內對應的變數，給功能程式碼運算。</li><li>功能程式碼：就是使用函式後，接收參數並進行功能運作的部分。</li></ul><h2 id="如何建創與調用函式"><a href="#如何建創與調用函式" class="headerlink" title="如何建創與調用函式"></a>如何建創與調用函式</h2><p>上面已經使用了一個建創方法</p><h3 id="函式陳述式"><a href="#函式陳述式" class="headerlink" title="函式陳述式"></a>函式陳述式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> 函式名 (<span class="hljs-params">參數</span>) </span>&#123;<br>  <span class="hljs-comment">/* 運作程式碼功能 */</span><br>&#125;<br>函式名 (參數);<br></code></pre></td></tr></table></figure><h3 id="函式表達式，匿名函式"><a href="#函式表達式，匿名函式" class="headerlink" title="函式表達式，匿名函式"></a>函式表達式，匿名函式</h3><p>上面有說函式名稱不一定會有，匿名函式就是沒有自己的名稱，而是直接賦值給變數使用，又稱<strong>函式表達式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> 變數名 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">參數</span>) </span>&#123;<br>  <span class="hljs-comment">/* 運作程式碼功能 */</span><br>&#125;<br>變數名 (參數);<br></code></pre></td></tr></table></figure><h3 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h3><p>跟物件與陣列一樣，使用 <code>new Function</code> 新增函式。<br>需注意：</p><ul><li>大小寫不能拼錯</li><li>參數與運作程式碼皆需要用<strong>字串型別</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> 變數名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> (<span class="hljs-string">&quot;參數&quot;</span>, <span class="hljs-string">&quot;運作程式碼&quot;</span>);<br></code></pre></td></tr></table></figure><p>但這個方法並不好用，而且<strong>效率低</strong>，因為程式碼會先把<strong>字串轉成它看得懂的程式碼</strong>，才進行運算。</p><h4 id="更多更多的-new"><a href="#更多更多的-new" class="headerlink" title="更多更多的 new"></a>更多更多的 new</h4><p>看到這裡你會發現～是不是所有型別都可以 new 出來。<br>沒錯！其實還可以用 new 來新增字串、數字、布林…等，但因為 new 基礎型別非常不常用，這裡就不多介紹 new 基本型別了。</p><h2 id="返回值（return）"><a href="#返回值（return）" class="headerlink" title="返回值（return）"></a>返回值（return）</h2><p>我們會運用功能了，但不想一直使用 <code>console.log</code> 印出來，想要讓函式結果繼續在程式碼裡面運算。<br>可以利用 <code>return</code> 把運算結果返回並終止函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = x + y;<br>  <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 使用 result 返回值，並終止函式</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;測試有沒有執行&quot;</span>)  <span class="hljs-comment">// return 後的程式碼不會執行</span><br>&#125;<br><span class="hljs-keyword">const</span> result = sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 返回的值 賦予到 result 變數上</span><br><span class="hljs-built_in">console</span>.log( result );  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="立即執行函式，IIFE（Immediately-Invoked-Function-Expression）"><a href="#立即執行函式，IIFE（Immediately-Invoked-Function-Expression）" class="headerlink" title="立即執行函式，IIFE（Immediately Invoked Function Expression）"></a>立即執行函式，IIFE（Immediately Invoked Function Expression）</h2><p>有些時候，我們只想在一開始使用一次函式，後續不會調用函式，就像進入超商會聽到歡迎光臨一樣。<br>此時不想占用變數空間，就可以使用匿名函式立即執行，需注意：</p><ul><li>匿名函式需要使用 <code>()</code> 包起來，不然 JavaScript 會認為你忘記為函式命名而報錯。</li><li>後面需像正常調用函式一樣，也可以和一般函式一樣帶入參數。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(text)<br>&#125; )(<span class="hljs-string">&quot;歡迎光臨&quot;</span>)<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(text)<br>&#125;(<span class="hljs-string">&quot;歡迎光臨&quot;</span>) )<br></code></pre></td></tr></table></figure><p>都可以使用，看個人（團體）習慣</p><h2 id="作用域（Scope）與-提升（Hoisting）"><a href="#作用域（Scope）與-提升（Hoisting）" class="headerlink" title="作用域（Scope）與 提升（Hoisting）"></a>作用域（Scope）與 提升（Hoisting）</h2><p>在我們宣告變數那一篇有介紹，全局作用域 與 函數作用域。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><ul><li><p>直接編寫 script 標籤中 JavaScript 程式碼，都會在全局作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(a);        <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>全局作用域在網頁打開時創建，在關閉網頁時清除。</p></li><li><p>在全局作用域有一個叫 <code>window</code> 的<strong>物件</strong>，代表瀏覽器的視窗，它由瀏覽器新增並供我們使用其內建的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>); <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在全局作用域中</p><ul><li><p>宣告變數都會變成 window 的屬性保存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>新增的函式會變成 window 的方法保存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">x,y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">window</span>.sum ); <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   function sum (x,y) &#123;</span><br><span class="hljs-comment">     return x + y;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="變數提升"><a href="#變數提升" class="headerlink" title="變數提升"></a>變數提升</h3><p>我們先從全局作用域看變數，會發現不管有沒有使用 <code>var</code> 宣告都會取得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = 1&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x = &quot;</span>+ x);  <span class="hljs-comment">// &quot;x = 2&quot;</span><br></code></pre></td></tr></table></figure><p>這時候我們把變數往後移，因為 Javascript 是由上向下一行一行執行，會發現有沒有宣告的差別。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = undefined&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x = &quot;</span>+ x);  <span class="hljs-comment">// 報錯 x is not defined </span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>有先進行 <code>var</code> 聲明宣告的變數，在執行程式碼之前會先提升至全局作用域的開頭，才執行程式碼，相當於：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a  <span class="hljs-comment">// var 聲明宣告會自動提升</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = undefined&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x = &quot;</span>+ x);  <span class="hljs-comment">// 報錯 x is not defined </span><br><br>a = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="函數提升"><a href="#函數提升" class="headerlink" title="函數提升"></a>函數提升</h3><p>一樣的，函數也會在程式執行前，會先自行提升，但函式有兩個新增方法，一個是函式陳述式，一個是函式表達式。<br>與上面一樣正常使用的話是不會報錯，但如果反過來？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fun()  <span class="hljs-comment">// &quot;我是一個 fun 函式&quot;</span><br>fun2() <span class="hljs-comment">// 報錯 fun2 is not a function</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一個 fun 函式&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fun2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一個 fun2 函式&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我想聰明的你，應該馬上就猜想到，沒錯！就是宣告變數提前，但變數的函式要到後面才會賦值，<code>undefined</code>當函式使用當然會報錯！</p><p>而使用函式陳述式，會把整個函式提升，在執行程式碼！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 函式陳述式把整個函式提升</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一個 fun 函式&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fun2;  <span class="hljs-comment">// var 自動提升宣告 undefined</span><br><br>fun()  <span class="hljs-comment">// &quot;我是一個 fun 函式&quot;</span><br>fun2() <span class="hljs-comment">// 報錯 fun2 is not a function</span><br><br>fun2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 到這裡才賦值</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一個 fun2 函式&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h3><ul><li><p>編寫在函式<strong>裡面</strong>的 Javascript 程式碼，這個區域就稱<strong>函式作用域</strong>。</p></li><li><p>函式作用域只在函式被<strong>調用</strong>時創建，在函式執行結束時清除。</p></li><li><p>每調用一次函式會創建一個<strong>新的函式作用域</strong>，函式作用域彼此都是<strong>獨立運作的</strong>。</p></li><li><p>函式作用域<strong>可以往外</strong>查找全局作用域的變數，全域作用域<strong>不能往內</strong>查找函式作用域的變數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = 1&quot;，函式內沒有 a 變數，會往全域找 a 變數</span><br>&#125;<br><br>echo();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b = &quot;</span>+ b);  <span class="hljs-comment">// 報錯 b is not defined，全域找不到 b 變數</span><br></code></pre></td></tr></table></figure></li><li><p>函式作用域中操作變數時，會<strong>先在自己的作用域</strong>尋找，沒有則會<strong>往上一層</strong>去尋找變數，一路查到全局作用域，直到找到為止，如果找不到就會報錯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;我是全局的 a&quot;</span>;<br><span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;我是全局的 c&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;我是 echo 內的 a&quot;</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;我是 echo 內的 b&quot;</span>;<br>  <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = 我是 echo 內的 a&quot;，函式內有 a 變數，優先使用</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ <span class="hljs-built_in">window</span>.a);  <span class="hljs-comment">// &quot;a = 我是全局的 a&quot;，利用 window 直接查找全局變數</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inside</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b = &quot;</span>+b); <span class="hljs-comment">// &quot;b = 我是 echo 內的 b&quot;，</span><br>      <span class="hljs-comment">// 函式內沒有 b 變數，往上一層 echo 內查找到 b 變數</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;c = &quot;</span>+c); <span class="hljs-comment">// &quot;c = 我是全局的 c&quot;，</span><br>      <span class="hljs-comment">// 函式內沒有 c 變數，往上一層 echo 內也查找不到變數，再往上一層查找。</span><br>  &#125;<br>&#125;<br><br>echo();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+ a);  <span class="hljs-comment">// &quot;a = 我是全局的 a&quot;，不會查找函式內的值</span><br></code></pre></td></tr></table></figure></li><li><p>定義<strong>參數</strong>，其實就等於在函式內<strong>宣告變數</strong>，所以就不會往外查找變數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> e = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e);<br>&#125;<br><br>echo();    <span class="hljs-comment">// undefined，因為 var e; 是 undefined</span><br>echo(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這邊已經先瞭解了基礎的函式，但函式的精隨 <code>this</code> 還沒介紹，介紹函式的同時也瞭解了宣告變數 <code>var</code> 的作用域與提升了～但宣告變數還有 <code>let</code> 與 <code>const</code> 的特性還沒有介紹！這等到後面要認識函式的精隨的時候，在一起解說～明天將先繼續挖深物件型別，加油！我們快脫離<strong>基礎篇</strong>了。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.17 「如果基本型別是商品，那物件型別就是購物袋」 —— JavaScript 物件型別</title>
    <link href="/2021/09/26/2021-9-26-it_ironman-day17/"/>
    <url>/2021/09/26/2021-9-26-it_ironman-day17/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-17-「如果基本型別是商品，那物件型別就是購物袋」-——-JavaScript-物件型別"><a href="#Day-17-「如果基本型別是商品，那物件型別就是購物袋」-——-JavaScript-物件型別" class="headerlink" title="Day.17 「如果基本型別是商品，那物件型別就是購物袋」 —— JavaScript 物件型別"></a>Day.17 「如果基本型別是商品，那物件型別就是購物袋」 —— JavaScript 物件型別</h1><p><img src="https://i.imgur.com/6P86wxa.png" alt="「如果基本型別是商品，那物件型別就是購物袋」 —— JavaScript 物件型別"></p><p>前面有介紹了基本型別，基本型別有 <code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code> 這五個型別，剩下的可以都歸類於物件型別。</p><h2 id="什麼是物件型別？"><a href="#什麼是物件型別？" class="headerlink" title="什麼是物件型別？"></a>什麼是物件型別？</h2><p>如同標題所說，基本型別所存入的值比較單純簡單，每個值都沒有關連，如同一個商店賣的商品一樣。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> coffee = <span class="hljs-number">45</span>;<br><span class="hljs-keyword">let</span> sandwich = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>而現在要來介紹的<strong>物件型別</strong>，就是由 <strong>0 個到多個</strong>的資料屬性所組合而成的，讓資料有<strong>關連性</strong>！就像我要購買咖啡與三明治一樣，讓這兩個商品裝進我的購物袋。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shopping_bag = &#123;<br>  <span class="hljs-attr">coffee</span>: <span class="hljs-number">45</span>,<br>  <span class="hljs-attr">sandwich</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>當然這只是簡單的比喻，實際並沒那麼簡單。</p><h2 id="物件（object）"><a href="#物件（object）" class="headerlink" title="物件（object）"></a>物件（object）</h2><p>先來介紹最基礎的<strong>物件（object）</strong></p><p>物件可以<strong>多個屬性值</strong>組合而成，屬於<strong>無序</strong>集合體，每個屬性都會有一個對應值，特色是由<code>&#123;&#125;</code>包起來。</p><p>就像一個人有名字（string）、性別（string）、年齡（number），就很適合用物件來新增。</p><h3 id="宣告物件的方法"><a href="#宣告物件的方法" class="headerlink" title="宣告物件的方法"></a>宣告物件的方法</h3><h4 id="利用-new-Object-新增物件"><a href="#利用-new-Object-新增物件" class="headerlink" title="利用 new Object() 新增物件"></a>利用 new Object() 新增物件</h4><p>這是以前新增物件的方法，利用 <code>new Object()</code> 幫變數新增 <code>&#123;&#125;</code> 空物件，再由賦值語句 <code>物件名.屬性名 = 屬性值</code>，進行<strong>新增物件屬性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>person.name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br>person.gender = <span class="hljs-string">&quot;男&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="利用空物件-新增物件"><a href="#利用空物件-新增物件" class="headerlink" title="利用空物件 {} 新增物件"></a>利用空物件 {} 新增物件</h4><p>這是現在大多數人都使用的方法，更簡單直觀，直接宣告物件並在裡面定義屬性 <code>&#123; key: value, key2: value &#125;</code>。<br>物件結構：</p><ul><li>使用 <code>&#123;&#125;</code> 包住</li><li>key 命名，盡量具有語意，<strong>盡量避免</strong>使用 數字、數字英文混和 與 空白鍵，如果 數字<strong>開頭</strong>與英文混和 或 含有空白鍵，需使用引號 <code>&#39;&#39;</code> 包起來，而單純數字就不需要引號包起來。</li><li>value 值可以是<strong>任何型別</strong>，只要遵守型別規則就可以了。</li><li>多個屬性值用 <code>,</code> 做區隔。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;毛毛&quot;</span>,<br>  <span class="hljs-attr">gender</span> : <span class="hljs-string">&quot;男&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="當然也可以先宣告空物件"><a href="#當然也可以先宣告空物件" class="headerlink" title="當然也可以先宣告空物件"></a>當然也可以先宣告空物件</h5><p>也可以透過宣告空物件，再看需要新增進去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;&#125;;<br>person.name = <span class="hljs-string">&quot;毛毛&quot;</span>;<br>person.gender = <span class="hljs-string">&quot;男&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="如何存取物件的-value-值"><a href="#如何存取物件的-value-值" class="headerlink" title="如何存取物件的 value 值"></a>如何存取物件的 value 值</h3><p>就跟前面新增屬性值的方法一樣</p><ul><li><p>使用 <code>.</code> 取值，通常都使用這個方式取值，比較直觀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;毛毛&quot;</span>,<br>  <span class="hljs-attr">gender</span> : <span class="hljs-string">&quot;男&quot;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log( person.name );  <span class="hljs-comment">// &quot;毛毛&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>[&quot;&quot;]</code> 取值，通常使用在 key 的命名法<strong>不符合</strong>常規變數命名時（如：<strong>數字開頭</strong> 或 <strong>字串中間有空格</strong>），藉由自動轉型使用中括號框起字串取值，如果 key 命名是<strong>純數字</strong>，可以不使用引號取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-number">1</span> : <span class="hljs-string">&quot;我是 1&quot;</span>,<br>  <span class="hljs-string">&quot;2a&quot;</span> : <span class="hljs-string">&quot;我是 2a&quot;</span>,<br>  <span class="hljs-string">&#x27;my name&#x27;</span>: <span class="hljs-string">&quot;毛毛&quot;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log( obj<span class="hljs-number">.1</span> );          <span class="hljs-comment">// 報錯</span><br><span class="hljs-built_in">console</span>.log( obj[<span class="hljs-number">1</span>] );         <span class="hljs-comment">// &quot;我是 1&quot;</span><br><span class="hljs-built_in">console</span>.log( obj[<span class="hljs-string">&quot;1&quot;</span>] );       <span class="hljs-comment">// &quot;我是 1&quot;</span><br><span class="hljs-built_in">console</span>.log( obj[2a] );        <span class="hljs-comment">// 報錯</span><br><span class="hljs-built_in">console</span>.log( obj[<span class="hljs-string">&quot;2a&quot;</span>] );      <span class="hljs-comment">// &quot;我是 2a&quot;</span><br><span class="hljs-built_in">console</span>.log( obj[my name] );   <span class="hljs-comment">// 報錯</span><br><span class="hljs-built_in">console</span>.log( obj[<span class="hljs-string">&quot;my name&quot;</span>] ); <span class="hljs-comment">// &quot;毛毛&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="如何新增物件屬性"><a href="#如何新增物件屬性" class="headerlink" title="如何新增物件屬性"></a>如何新增物件屬性</h3><p>眼尖的人應該已經有發現，其實前面介紹如何新增物件時，就有新增物件屬性。<br><strong>需注意</strong> 物件的 <code>key</code> 會<strong>自動轉型成字串型別</strong>，而 <code>value</code> 可以存任何型別。</p><p>而新增方法其實就跟存取方法幾乎一模一樣，使用賦值語句直接賦值即可！如：<code>person.name = &quot;毛毛&quot;;</code><br>注意的要點也差不多，盡量使用有語意的字串來命名 key。</p><h3 id="如何刪除物件屬性"><a href="#如何刪除物件屬性" class="headerlink" title="如何刪除物件屬性"></a>如何刪除物件屬性</h3><p>這就要使用到一元運算子 <code>delete</code>，在要刪除的屬性前面使用 <code>delete</code> 就會刪除屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wallet = &#123;&#125;;   <span class="hljs-comment">// 設一個錢包</span><br>wallet.money = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 錢包內多了 1000 元</span><br><span class="hljs-built_in">console</span>.log( wallet.money );  <span class="hljs-comment">// 1000</span><br><br><span class="hljs-keyword">delete</span> wallet.money; <span class="hljs-comment">// 錢包內移除了 1000 元</span><br><span class="hljs-built_in">console</span>.log( wallet.money );  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="陣列（array）"><a href="#陣列（array）" class="headerlink" title="陣列（array）"></a>陣列（array）</h2><p>跟物件（object）有點相似，陣列也是<strong>多個值</strong>組合而成。<br>與物件不一樣的是，屬於<strong>有序</strong>集合體，陣列的屬性名為數字索引，陣列<strong>索引</strong>號碼由 <strong>0</strong> 開始。<br>雖然可以有很多不同的值組合，但通常都會放同類型、具有關聯性的值統合成陣列。</p><p>就像一個班級有你（string）、我（string）、他（string），都是班級裡的學生，就很適合用陣列。</p><h3 id="宣告陣列的方法"><a href="#宣告陣列的方法" class="headerlink" title="宣告陣列的方法"></a>宣告陣列的方法</h3><p>其實跟宣告物件的方法差不多，你會覺得似曾相似。<br>就想像原本的所有屬性值，變成<strong>有序</strong>的索引值就好。</p><h4 id="利用-new-Array-新增陣列"><a href="#利用-new-Array-新增陣列" class="headerlink" title="利用 new Array() 新增陣列"></a>利用 new Array() 新增陣列</h4><p>這是以前新增陣列的方法，利用 <code>new Array()</code> 幫變數新增 <code>[]</code> 空物件，再由賦值語句 <code>陣列名[ 索引號碼 ] = 屬性值</code>，進行<strong>新增陣列內容</strong>。<br>因為<strong>索引號碼</strong>一定是有序數字，所以只能使用 <code>陣列名[ 索引號碼 ]</code> 來新增存取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>person[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;花花&quot;</span>;<br>person[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;泡泡&quot;</span>;<br>person[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;毛毛&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="利用空陣列-新增物件"><a href="#利用空陣列-新增物件" class="headerlink" title="利用空陣列 [] 新增物件"></a>利用空陣列 [] 新增物件</h4><p>這是現在大多數人都使用的方法，更簡單直觀，直接宣告陣列並在裡面定義屬性 <code>[ value, value ]</code>。<br>陣列結構：</p><ul><li>使用 <code>[]</code> 包住</li><li>value 值可以是<strong>任何型別</strong>，但通常使用陣列的 value 值會具有相關性。</li><li>多個 value 值用 <code>,</code> 做區隔。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span> ];<br></code></pre></td></tr></table></figure><h5 id="當然也可以先宣告空陣列"><a href="#當然也可以先宣告空陣列" class="headerlink" title="當然也可以先宣告空陣列"></a>當然也可以先宣告空陣列</h5><p>也可以透過宣告空物件，再看需要新增進去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [];<br>person[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;花花&quot;</span>;<br>person[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;泡泡&quot;</span>;<br>person[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;毛毛&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="如何-新增-與-刪除-陣列索引"><a href="#如何-新增-與-刪除-陣列索引" class="headerlink" title="如何 新增 與 刪除 陣列索引"></a>如何 新增 與 刪除 陣列索引</h3><p>這聰明的你應該馬上就猜到！沒錯～跟物件使用的方法非常像，因為索引值都是數字，所以直接用 <code>[]</code> 來存取陣列索引值就可以了！<br>但是陣列還有更好的新增刪除方法。</p><p>如果是用索引直接新增，會產生一個問題。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span> ];<br><br><span class="hljs-comment">/* 這時一個手殘，把索引值案到 9 */</span><br>person[<span class="hljs-number">9</span>] = <span class="hljs-string">&quot;尤教授&quot;</span>;<br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, , , , , , , &quot;尤教授&quot; ]</span><br></code></pre></td></tr></table></figure><p>你會發現索引值打錯，會多很多個還沒定義的索引值先占位子！<br>每次新增刪除都還要小心翼翼地計算索引值。</p><h4 id="在陣列最末端新增索引值-push"><a href="#在陣列最末端新增索引值-push" class="headerlink" title="在陣列最末端新增索引值 push()"></a>在陣列最末端新增索引值 push()</h4><p>這時候使用 <code>push()</code> 這個方法就能無後顧之憂的在陣列最後面新增索引值了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span> ];<br><br>person.push(<span class="hljs-string">&quot;尤教授&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, &quot;尤教授&quot; ]</span><br></code></pre></td></tr></table></figure><h4 id="刪除陣列最末端的索引值-pop"><a href="#刪除陣列最末端的索引值-pop" class="headerlink" title="刪除陣列最末端的索引值 pop()"></a>刪除陣列最末端的索引值 pop()</h4><p>有新增就會有刪除！使用 <code>pop()</code> 這個方法就能毫無顧忌地刪除陣列最後的索引值了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;尤教授&quot;</span>, <span class="hljs-string">&quot;魔鞋啾啾&quot;</span> ];<br><br>person.pop();<br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, &quot;尤教授&quot; ]</span><br></code></pre></td></tr></table></figure><h4 id="刪除-與-新增-最前頭的索引值-shift-與-unshift"><a href="#刪除-與-新增-最前頭的索引值-shift-與-unshift" class="headerlink" title="刪除 與 新增 最前頭的索引值 shift() 與 unshift()"></a>刪除 與 新增 最前頭的索引值 shift() 與 unshift()</h4><p>既然有處理陣列最末端的，當然也有處理陣列最前頭的索引值！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;魔鞋啾啾&quot;</span>, <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;尤教授&quot;</span> ];<br><br>person.shift();<br><span class="hljs-built_in">console</span>.log( person );    <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, &quot;尤教授&quot; ]</span><br>person.unshift(<span class="hljs-string">&quot;魔人啾啾&quot;</span>);<br><span class="hljs-built_in">console</span>.log( person );    <span class="hljs-comment">// [ &quot;魔人啾啾&quot;, &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, &quot;尤教授&quot; ]</span><br></code></pre></td></tr></table></figure><h4 id="如何獲取陣列的長度-length"><a href="#如何獲取陣列的長度-length" class="headerlink" title="如何獲取陣列的長度 length"></a>如何獲取陣列的長度 length</h4><p>有時候陣列很長時，可以依靠 <code>length</code> 語法來獲取陣列的長度！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;尤教授&quot;</span>, <span class="hljs-string">&quot;魔人啾啾&quot;</span> ];<br><br><span class="hljs-built_in">console</span>.log( person.length );  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h5 id="甚至修改陣列長度"><a href="#甚至修改陣列長度" class="headerlink" title="甚至修改陣列長度"></a>甚至修改陣列長度</h5><p>利用 <code>length</code> 修改陣列，讓陣列直接刪除多餘的值 或 添加未定義的值！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span>, <span class="hljs-string">&quot;尤教授&quot;</span>, <span class="hljs-string">&quot;魔人啾啾&quot;</span> ];<br>person.length = <span class="hljs-number">3</span>; <span class="hljs-comment">// 把陣列長度修改為 3</span><br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot; ]</span><br>person.length = <span class="hljs-number">5</span>; <span class="hljs-comment">// 在修改回 5</span><br><span class="hljs-built_in">console</span>.log( person );  <span class="hljs-comment">// [ &quot;花花&quot;, &quot;泡泡&quot;, &quot;毛毛&quot;, , ]</span><br></code></pre></td></tr></table></figure><h5 id="除了用在陣列也能用在字串"><a href="#除了用在陣列也能用在字串" class="headerlink" title="除了用在陣列也能用在字串"></a>除了用在陣列也能用在字串</h5><p><code>length</code> 除了可以用在察看陣列的長度，也能用來查看字串的字數，不過跟陣列不同的是不能修改字串的長度！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Mao&quot;</span>;<br><span class="hljs-built_in">console</span>.log( name.length );  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="還有更多方法"><a href="#還有更多方法" class="headerlink" title="還有更多方法"></a>還有更多方法</h4><p>還有很多陣列方法可以使用，有興趣的可以再去看 <a href="https://www.oxxostudio.tw/articles/201908/js-array.html">JavaScript Array 陣列操作方法</a></p><h2 id="如何透過程式碼判斷-陣列-和-物件"><a href="#如何透過程式碼判斷-陣列-和-物件" class="headerlink" title="如何透過程式碼判斷 陣列 和 物件"></a>如何透過程式碼判斷 陣列 和 物件</h2><p>前面我們有教過一元運算子的 <code>typeof</code> 可以用來判斷型別，但會發現判斷陣列與物件時，回傳的都是 <code>&quot;object&quot;</code>！<br>這時候 JavaScript 有新增一個判斷陣列的方法 <code>Array.isArray()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-keyword">const</span> person = [ <span class="hljs-string">&quot;花花&quot;</span>, <span class="hljs-string">&quot;泡泡&quot;</span>, <span class="hljs-string">&quot;毛毛&quot;</span> ];<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Array</span>.isArray(arr) );      <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Array</span>.isArray(person) );   <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Array</span>.isArray(obj) );      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這邊先大概瞭解了物件型別的基礎了～至少會定義與增刪改查，物件型別這個坑還很深，我們現在才剛踏進去，明天先介紹函式（function），介紹完函式，我們再繼續把物件型別這個坑挖深！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li><li><a href="https://www.oxxostudio.tw/articles/201908/js-array.html">JavaScript Array 陣列操作方法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.16 「重複的事情，交給程式去做！」 —— JavaScript 循環迴圈</title>
    <link href="/2021/09/25/2021-9-25-it_ironman-day16/"/>
    <url>/2021/09/25/2021-9-25-it_ironman-day16/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-16-「重複的事情，交給程式去做！」-——-JavaScript-循環迴圈"><a href="#Day-16-「重複的事情，交給程式去做！」-——-JavaScript-循環迴圈" class="headerlink" title="Day.16 「重複的事情，交給程式去做！」 —— JavaScript 循環迴圈"></a>Day.16 「重複的事情，交給程式去做！」 —— JavaScript 循環迴圈</h1><p><img src="https://i.imgur.com/0bAwQpd.png" alt="「重複的事情，交給程式去做！」 —— JavaScript 循環迴圈"></p><p>前面學習到了條件判斷式，接著我們來學習有點<del>危險</del>的<strong>循環迴圈</strong>，好啦！也沒那麼誇張～只是寫不好，容易進入無窮迴圈導致當機！不過我們是寫在網頁上～所以如果真的不小心陷入無窮迴圈，就關掉瀏覽器就可以了！</p><h2 id="什麼是迴圈？"><a href="#什麼是迴圈？" class="headerlink" title="什麼是迴圈？"></a>什麼是迴圈？</h2><p>如同字面上的意思，一直反覆輪迴，重複做一樣的事（<del>怎麼好像人生</del>）。</p><h2 id="迴圈流程圖"><a href="#迴圈流程圖" class="headerlink" title="迴圈流程圖"></a>迴圈流程圖</h2><p>沒錯！迴圈也有流程圖，但其實也跟判斷流程圖相差不遠，幾乎一模一樣</p><p><img src="https://i.imgur.com/nfy4vsd.png" alt="迴圈流程圖"></p><p>同樣是要達成所設定的條件來進行循環，是不是跟條件判斷式很像呀！</p><h2 id="while-迴圈"><a href="#while-迴圈" class="headerlink" title="while 迴圈"></a>while 迴圈</h2><p>while 迴圈是個最基本、結構簡單的迴圈，使用的語法 <code>while ( 條件表達式 ) &#123; 當條件表達式為 true 時，執行程式碼 &#125;</code>。</p><p>假設我們要印出 12 個月份，除了乖乖的打出 12 個月份，我們也可以發揮工程師精神，使用迴圈來幫我們代勞：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> month = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 一年由 1 月開始 */</span><br><span class="hljs-keyword">while</span> (month &lt;= <span class="hljs-number">12</span> <span class="hljs-comment">/* 一年只有 12 個月，超過就終止 */</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`<span class="hljs-subst">$&#123;month&#125;</span> 月`</span> );  <span class="hljs-comment">// 利用前面所學的樣板字面值，帶入變數</span><br>  month++;  <span class="hljs-comment">// 重點：需要每執行一次自動 + 1，否則會陷入無限迴圈</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;1 月&quot;</span><br><span class="hljs-comment">  &quot;2 月&quot;</span><br><span class="hljs-comment">  &quot;3 月&quot;</span><br><span class="hljs-comment">  &quot;4 月&quot;</span><br><span class="hljs-comment">  &quot;5 月&quot;</span><br><span class="hljs-comment">  &quot;6 月&quot;</span><br><span class="hljs-comment">  &quot;7 月&quot;</span><br><span class="hljs-comment">  &quot;8 月&quot;</span><br><span class="hljs-comment">  &quot;9 月&quot; </span><br><span class="hljs-comment">  &quot;10 月&quot;</span><br><span class="hljs-comment">  &quot;11 月&quot;</span><br><span class="hljs-comment">  &quot;12 月&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>非常簡單吧～</p><h2 id="do-while-迴圈"><a href="#do-while-迴圈" class="headerlink" title="do while 迴圈"></a>do while 迴圈</h2><p>而 do while 跟 while 非常相似，唯一不同的地方就在於，JavaScript 是由上而下執行程式碼，所以會<strong>先執行一次</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> month = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 一年由 1 月開始 */</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// 不管有沒有符合條件，都會先執行&quot;一次&quot;這段程式碼</span><br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`<span class="hljs-subst">$&#123;month&#125;</span> 月`</span> );<br>  month++; <span class="hljs-comment">// 重點記得加</span><br>&#125; <span class="hljs-keyword">while</span> (month &lt;= <span class="hljs-number">12</span>) <span class="hljs-comment">// 一年不超過 12 個月</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;1 月&quot;</span><br><span class="hljs-comment">  &quot;2 月&quot;</span><br><span class="hljs-comment">  &quot;3 月&quot;</span><br><span class="hljs-comment">  &quot;4 月&quot;</span><br><span class="hljs-comment">  &quot;5 月&quot;</span><br><span class="hljs-comment">  &quot;6 月&quot;</span><br><span class="hljs-comment">  &quot;7 月&quot;</span><br><span class="hljs-comment">  &quot;8 月&quot;</span><br><span class="hljs-comment">  &quot;9 月&quot; </span><br><span class="hljs-comment">  &quot;10 月&quot;</span><br><span class="hljs-comment">  &quot;11 月&quot;</span><br><span class="hljs-comment">  &quot;12 月&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a>for 迴圈</h2><p>for 迴圈比較嚴謹，它把設定<strong>初始值</strong>、<strong>條件判斷</strong> 與 <strong>更新值</strong> 集中在一起設定，讓迴圈的操控次數更容易掌控。</p><p>for 迴圈的語法 <code>for (初始化表達式; 條件表達式; 更新表達式) &#123; 條件判斷為 true 執行程式碼 &#125;</code></p><p>同樣用上面 12 個月的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 同樣設定初始值 1 月; 不超過 12 個月; 每執行一次 + 1 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span> 月`</span> );<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;1 月&quot;</span><br><span class="hljs-comment">  &quot;2 月&quot;</span><br><span class="hljs-comment">  &quot;3 月&quot;</span><br><span class="hljs-comment">  &quot;4 月&quot;</span><br><span class="hljs-comment">  &quot;5 月&quot;</span><br><span class="hljs-comment">  &quot;6 月&quot;</span><br><span class="hljs-comment">  &quot;7 月&quot;</span><br><span class="hljs-comment">  &quot;8 月&quot;</span><br><span class="hljs-comment">  &quot;9 月&quot; </span><br><span class="hljs-comment">  &quot;10 月&quot;</span><br><span class="hljs-comment">  &quot;11 月&quot;</span><br><span class="hljs-comment">  &quot;12 月&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>有沒有發現更簡單了！<br>大多數人會喜歡使用 <code>let i</code> 來初始化元素，是因為 <code>let</code> 是區塊變數，不會汙染到外面的變數，而 <code>i</code> 是 <code>index</code> 的縮寫，當然你變數名取別的也無所謂就是了！</p><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h2><p>有時候我們並不想讓迴圈直接執行到底，想要跳過幾個選項，或到哪個選項直接停止，就可以利用 break （中斷語法）與　continue （跳過語法），只能使用在循環語法中。<br>是不是很熟悉～沒錯！就是前面 switch 中的 <code>break</code> 語法，switch 也可以搭配 <code>continue</code> 進行跳過。</p><p><code>break</code> 用法應該都知道了，這裡就介紹 <code>continue</code> 吧～<br>使用方法也很簡單，假如我想在印出 9 月有幾天紅字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> holiday = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 統計假日</span><br><br><span class="hljs-comment">/* 同樣設定初始值 1 日; 9 月不超過 30 天; 每執行一次 + 1 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br><br>  <span class="hljs-comment">// 1 號是從星期三開始的，判斷如果是星期一到五的話 continue 跳過</span><br>  <span class="hljs-keyword">if</span> ( (i + <span class="hljs-number">2</span>) % <span class="hljs-number">7</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; (i + <span class="hljs-number">2</span>) % <span class="hljs-number">7</span> &lt;= <span class="hljs-number">5</span> ) <span class="hljs-keyword">continue</span>;<br>  <br>  <span class="hljs-comment">// 沒被 continue 跳過的，會在這行程式碼進行 + 1</span><br>  holiday++;<br>&#125;<br><br>holiday += <span class="hljs-number">1</span>; <span class="hljs-comment">// 不能忘了中秋節是在星期二</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`紅字有 <span class="hljs-subst">$&#123;holiday&#125;</span> 天`</span>); <span class="hljs-comment">// 紅字有 9 天</span><br></code></pre></td></tr></table></figure><h2 id="for-迴圈-與-while-迴圈-的差別"><a href="#for-迴圈-與-while-迴圈-的差別" class="headerlink" title="for 迴圈 與 while 迴圈 的差別"></a>for 迴圈 與 while 迴圈 的差別</h2><p>就如同我上一篇所說，既然 for 迴圈 和 while 迴圈 使用的情況與結果都差不多，那為什麼還會存在，一定是有它的意義在！</p><p>大多數的情況，都會使用 for 迴圈，是因為 for 迴圈把控制迴圈次數的條件都集中一起寫，閱讀性比較高，適合 <strong>條件次數明確</strong> 的情況使用。</p><p>而當<strong>條件次數不明確</strong>呢？ 沒錯！就要利用 while 迴圈來達成了！while 迴圈在面對隨機性的時候，只要<strong>條件</strong>的部分符合，不用像 for 迴圈要設定好三個值，<strong>while 迴圈</strong>就比 <strong>for 迴圈</strong>會更加靈活好用且更直覺。</p><p>這邊舉一下 <a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a> 書中很好的例子，當大樂透要使用「電腦選號」時，迴圈要如何判定呢？ 規則：「從 1～49中，隨機選9個不重複的號碼」，這就留給各位思考了。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.15 「條件設定好～讓程式判斷！」 —— JavaScript 條件判斷式</title>
    <link href="/2021/09/24/2021-9-24-it_ironman-day15/"/>
    <url>/2021/09/24/2021-9-24-it_ironman-day15/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-15-「條件設定好～讓程式判斷！」-——-JavaScript-條件判斷式"><a href="#Day-15-「條件設定好～讓程式判斷！」-——-JavaScript-條件判斷式" class="headerlink" title="Day.15 「條件設定好～讓程式判斷！」 —— JavaScript 條件判斷式"></a>Day.15 「條件設定好～讓程式判斷！」 —— JavaScript 條件判斷式</h1><p><img src="https://i.imgur.com/Zso8daX.png" alt="「條件設定好～讓程式判斷！」 —— JavaScript 條件判斷式"></p><p>前面學習了基礎的變數與運算子的使用，這些基礎往往是非常枯燥乏味的，還沒有與電腦有更進一步的互動，所以感受不到程式語言的魅力，而今天學習的條件判斷式就可以開始與電腦進行些微的互動！</p><h2 id="什麼是條件判斷式？"><a href="#什麼是條件判斷式？" class="headerlink" title="什麼是條件判斷式？"></a>什麼是條件判斷式？</h2><p>就「條件判斷」字面上的意思，由我們設定<strong>條件</strong>，讓電腦幫我們判斷是否執行後續程式碼。</p><h2 id="判斷流程圖"><a href="#判斷流程圖" class="headerlink" title="判斷流程圖"></a>判斷流程圖</h2><p>在寫條件判斷式之前，通常會先思考這個條件設下的流程圖要怎麼規劃！</p><p>例如，判斷用戶資料是否有成年如下：<br><img src="https://i.imgur.com/8MzkGYV.png" alt="判斷流程圖"></p><p>有的人喜歡在腦中規劃，有的人喜歡著手畫出來，也有的人喜歡利用線上軟體進行規劃，只要能讓自己規劃出流程、整理出思緒的都是好方法。</p><p>通常為了讓<strong>大家</strong>都能一下就看得懂，流程圖的形狀也都有定義，當然如果只有你自己看，你想要什麼形狀就什麼形狀。<br><img src="https://i.imgur.com/3Dy8YqY.png" alt="流程圖形狀表"></p><p>我在這裡推薦一個可以製作流程圖的線上網站 <a href="https://whimsical.com/">Whimsical</a>，至於如何使用，就自己好好摸索一下就懂了，我就不再這多加著墨了。</p><h2 id="if-條件判斷式結構"><a href="#if-條件判斷式結構" class="headerlink" title="if 條件判斷式結構"></a>if 條件判斷式結構</h2><p>想好流程圖後，接著就是實踐了！<br>if 條件判斷式結構 <code>if ( 條件 ) &#123; 達成條件執行這段程式碼 &#125; else &#123; 否則執行 else 後的程式碼 &#125;</code> 就如上面例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">27</span>;<br><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span> <span class="hljs-comment">/* () 內寫判斷條件 */</span>) &#123;<br>  <span class="hljs-comment">/* 當符合條件就會執行這段 &#123;&#125; 內的程式碼 */</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你成年了！享受吧～&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 否則就會執行 else 後，這段 &#123;&#125; 內的程式碼 */</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你未成年不能進入！&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="簡化方式"><a href="#簡化方式" class="headerlink" title="簡化方式"></a>簡化方式</h3><p>當你的判斷條件執行的結構非常簡單，執行程式只有單純的一行，可以省略 <code>&#123;&#125;</code><br>以上面作為範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">27</span>;<br><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你成年了！享受吧～&#x27;</span>) <span class="hljs-comment">// 只有單純一行可以省略 &#123;&#125;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你未成年不能進入！&#x27;</span>) <span class="hljs-comment">// 只有單純一行可以省略 &#123;&#125;</span><br>  <br><span class="hljs-comment">/* 甚至更簡化 */</span><br><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你成年了！享受吧～&#x27;</span>) <span class="hljs-comment">// 只有單純一行可以省略 &#123;&#125;</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你未成年不能進入！&#x27;</span>) <span class="hljs-comment">// 只有單純一行可以省略 &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>當然不推薦貿然使用，一切依照<strong>可讀性</strong>為準！</p><h3 id="多個條件判斷式"><a href="#多個條件判斷式" class="headerlink" title="多個條件判斷式"></a>多個條件判斷式</h3><p>除了判斷是否成年外，也能使用 <code>else if ()</code> 來達成多個條件來判斷處在哪個年齡階段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">27</span>;<br><span class="hljs-keyword">let</span> ageGrades = <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">65</span> <span class="hljs-comment">/* () 內寫判斷條件 */</span>) &#123;<br>  ageGrades = <span class="hljs-string">&#x27;老年&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">65</span> &amp;&amp; age &gt;= <span class="hljs-number">18</span>) &#123;<br>  ageGrades = <span class="hljs-string">&#x27;青壯年&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  ageGrades = <span class="hljs-string">&#x27;幼年&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log( ageGrades ) <span class="hljs-comment">// &quot;青壯年&quot;</span><br></code></pre></td></tr></table></figure><h4 id="此外不一定要寫-else"><a href="#此外不一定要寫-else" class="headerlink" title="此外不一定要寫 else"></a>此外不一定要寫 else</h4><p>有時候條件判斷式只是想判斷是否有達成條件，沒達成條件不會執行程式碼，就可以省略 else 後面這段，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (ageGrades === <span class="hljs-string">&#x27;青壯年&#x27;</span>) alert(<span class="hljs-string">&#x27;你現在正處在人生最顛峰的階段～加油！&#x27;</span>) <br></code></pre></td></tr></table></figure><h2 id="三元運算子（條件運算子）"><a href="#三元運算子（條件運算子）" class="headerlink" title="三元運算子（條件運算子）"></a>三元運算子（條件運算子）</h2><p>這個跟 if 條件判斷式非常相似，三元運算子結構 <code>( 條件 ) ? 達成條件回傳這段 : 未達成回傳這段</code>，<strong>需注意</strong> 它是運算子！表達式會回傳值！所以很常直接進行判斷賦值。如下：</p><blockquote><p>什麼是表達式？ 表達式會自動回傳結果，最常見的就是運算子<br>除了表達式還有別的嗎？ 還有陳述式，與表達式相反，不會回傳結果，主要是執行程式碼的片段，例如：if 條件判斷式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">27</span>;<br><br><span class="hljs-keyword">let</span> adult = (age &gt;= <span class="hljs-number">18</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// 這是為了展示條件判斷後直接賦值</span><br><br>adult ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你成年了！享受吧～&#x27;</span>) : <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你未成年不能進入！&#x27;</span>); <span class="hljs-comment">// &quot;你成年了！享受吧～&quot;</span><br><br><span class="hljs-comment">/*  當然這段其實可以直接簡化成  */</span><br>(age &gt;= <span class="hljs-number">18</span>) ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你成年了！享受吧～&#x27;</span>) : <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你未成年不能進入！&#x27;</span>); <span class="hljs-comment">// &quot;你成年了！享受吧～&quot;</span><br></code></pre></td></tr></table></figure><h2 id="switch-條件判斷式"><a href="#switch-條件判斷式" class="headerlink" title="switch 條件判斷式"></a>switch 條件判斷式</h2><p>switch 條件判斷式，非常適合處理條件明確，判斷流程長的條件判斷式了，這邊就使用 <a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a> 所舉的例子吧！<br>一年有 12 個月，4個季節，從我們熟知的 if 慢慢優化到 switch：</p><h3 id="使用-if-條件判斷式"><a href="#使用-if-條件判斷式" class="headerlink" title="使用 if 條件判斷式"></a>使用 if 條件判斷式</h3><p>這是個非常直覺的用法！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> ( month &gt;= <span class="hljs-number">1</span> &amp;&amp; month &lt;=<span class="hljs-number">3</span> ) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;春天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( month &gt;= <span class="hljs-number">4</span> &amp;&amp; month &lt;=<span class="hljs-number">6</span> ) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;夏天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( month &gt;= <span class="hljs-number">7</span> &amp;&amp; month &lt;=<span class="hljs-number">9</span> ) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;秋天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( month &gt;= <span class="hljs-number">10</span> &amp;&amp; month &lt;=<span class="hljs-number">12</span> ) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;冬天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;月份錯誤&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但會發現判斷條件有點長，容易寫錯不好維護，<br>於是簡化條件，先定義季節代號的變數，並利用 <code>Math.ceil()</code> 小數點無條件進位的方法簡化。<br>這樣利用變數管理，更易於維護，也比較<strong>不容易寫錯</strong>條件導致 bug。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> seasonType = <span class="hljs-built_in">Math</span>.ceil( month / <span class="hljs-number">3</span> );<br><br><span class="hljs-keyword">if</span> ( seasonType === <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;春天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( seasonType === <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;夏天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( seasonType === <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;秋天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( seasonType === <span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;冬天&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;月份錯誤&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但這也是有缺點，判斷式寫太長，效率會不太好，還有更好的優化方法，那就是使用我們的 switch 條件判斷</p><h3 id="使用-switch-優化"><a href="#使用-switch-優化" class="headerlink" title="使用 switch 優化"></a>使用 switch 優化</h3><p>switch 的語法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* switch 是關鍵詞 */</span><br><span class="hljs-keyword">switch</span> ( <span class="hljs-built_in">Math</span>.ceil( month / <span class="hljs-number">3</span> ) <span class="hljs-comment">/* 輸入值 */</span> ) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// 比對值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;春天&#x27;</span>); <span class="hljs-comment">// 輸入值 與 比對值 &quot;全等&quot;才會執行這段</span><br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 中斷判斷跳出</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;夏天&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;秋天&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;冬天&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;月份錯誤&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是更簡單清楚明瞭了呢！</p><p>switch 重點：</p><ol><li><strong>輸入值</strong>可以是變數，也可以是表達式，只要得出的值有辦法對應比對值就可以了</li><li><strong>輸入值</strong> 與 <strong>比對值</strong>必須<strong>全等</strong>才行，屬於嚴格比對！</li><li><code>break</code> 通常情況下會加上去，不然判斷不會自己中斷，會從比對成功的程式碼一路執行下去，直到碰到 <code>break</code></li><li><code>default</code> 主要功能是，當條件都沒辦法達成時，會執行這段，與 <code>else</code> 一樣不一定要添加，一個 switch 只能使用<strong>一個</strong></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>人是有惰性的，不常使用的語法有時候會忘記！<br>以前的我就不常使用 switch，心想反正 if 就能用了，<del>我就懶</del>，後來仔細想想，既然處理的事情差不多，那它存在一定有它的意義在，在好奇心驅使下，去查閱了 if 與 switch 有什麼不同！查了才發現～原來在判斷流程長的時候，使用 switch 的效能會比使用 if 還來的好，也更容易維護，於是能使用 switch 的時候，我都盡量使用，能簡化不失閱讀性，就盡量簡化，把工程師的懶，發揮到極致！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.14 「基礎打穩了，就能走得更長久～」 —— JavaScript 基礎運算子</title>
    <link href="/2021/09/23/2021-9-23-it_ironman-day14/"/>
    <url>/2021/09/23/2021-9-23-it_ironman-day14/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-14-「基礎打穩了，就能走得更長久～」-——-JavaScript-基礎運算子"><a href="#Day-14-「基礎打穩了，就能走得更長久～」-——-JavaScript-基礎運算子" class="headerlink" title="Day.14 「基礎打穩了，就能走得更長久～」 —— JavaScript 基礎運算子"></a>Day.14 「基礎打穩了，就能走得更長久～」 —— JavaScript 基礎運算子</h1><p><img src="https://i.imgur.com/0XXiCaD.png" alt="「基礎打穩了，就能走得更長久～」 —— JavaScript 基礎運算子"></p><p>學習任何東西，都要把基礎學的扎實，基礎穩了，遇到問題就能迎刃而解。<br>而學習程式語言的基礎就是數學邏輯，不用到很專精，只要有基礎數學邏輯，多寫多做就能鍛鍊出寫程式邏輯的<del>金魚</del>腦，基礎邏輯打穩了，任何程式語言都有相似的地方，會越學越快，<del>然後發現根本是無底洞，沒有盡頭</del>。</p><h2 id="算數運算子"><a href="#算數運算子" class="headerlink" title="算數運算子"></a>算數運算子</h2><p>就如同我們國小上課一樣，算數就要先從 加、減、乘、除 的基礎開始教起，而運算先後順序就如同我們國中所學的，<strong>先乘除</strong>、<strong>後加減</strong>、<strong>有括號先算括號</strong>，這對聰明的你來說，實在是小 case！</p><table><thead><tr><th align="center">運算符</th><th align="center">說明</th><th align="center">運算符</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加法</td><td align="center"><code>++</code></td><td align="center">自增</td></tr><tr><td align="center"><code>-</code></td><td align="center">減法</td><td align="center"><code>--</code></td><td align="center">自減</td></tr><tr><td align="center"><code>*</code></td><td align="center">乘法</td><td align="center"><code>**</code></td><td align="center">次方</td></tr><tr><td align="center"><code>/</code></td><td align="center">除法</td><td align="center"><code>%</code></td><td align="center">餘數</td></tr></tbody></table><h3 id="一元運算符"><a href="#一元運算符" class="headerlink" title="一元運算符"></a>一元運算符</h3><p>前面變數轉型那一篇有稍微提到使用 <code>+</code> 的一元運算符，來為變數轉型成<strong>數字型別</strong>。<br>而使用 <code>-</code> 的一元運算符，聰明的你，一定馬上就猜出來，是把型別變成數字型別的<strong>相反數</strong>。<br><code>typeof</code> 本身也是一元運算符，是用來判斷型別的。</p><h3 id="字串串接"><a href="#字串串接" class="headerlink" title="字串串接"></a>字串串接</h3><p>利用 <code>+</code> 運算符，可以進行字串串接，當 <code>+</code> 兩邊其中一邊為<strong>字串（string）型態</strong>時，JavaScript 會自動幫我們把兩邊的轉型成字串型態，並進行串接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;10&#x27;</span>;<br><span class="hljs-keyword">let</span> c;<br><span class="hljs-built_in">console</span>.log( a + b ); <span class="hljs-comment">// &quot;1010&quot;</span><br><span class="hljs-built_in">console</span>.log( b + c ); <span class="hljs-comment">// &quot;10undefined&quot;</span><br></code></pre></td></tr></table></figure><h3 id="自增-與-自減"><a href="#自增-與-自減" class="headerlink" title="自增 與 自減"></a>自增 與 自減</h3><p><code>++</code> 與 <code>--</code> 可以對自己數字 <strong>增加 1</strong> 或 <strong>減少 1</strong>。<br>放在變數前後的位置很重要！<br>當運算符在前面時 <code>++a</code>，<strong>當下</strong>為變數更改後的數值，想像已經先 <code>+1</code>。<br>當運算符在後面時 <code>a++</code>，<strong>當下</strong>為變數的原本數值，想像已經先賦值還來不及 <code>+1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = a++; <span class="hljs-comment">// b = 10</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> d = ++c; <span class="hljs-comment">// d = 11</span><br><br><span class="hljs-built_in">console</span>.log(a, b, c, d) <span class="hljs-comment">// 11, 10, 11, 11</span><br></code></pre></td></tr></table></figure><h2 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子"></a>邏輯運算子</h2><table><thead><tr><th align="center">運算符</th><th align="center">說明</th><th align="center">判斷<strong>中斷</strong>規則</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center"><code>!</code></td><td align="center">非（not）</td><td align="center">無</td><td align="center">返回與原本<strong>布林值相反的值</strong></td></tr><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">和（and）</td><td align="center">如果左側為 <code>false</code>，則<strong>不判斷</strong>右側值</td><td align="center">如果左側為 <code>false</code>，返回<strong>左側</strong>的<strong>值</strong>，反之亦然</td></tr><tr><td align="center"><code>∣∣</code></td><td align="center">或（or）</td><td align="center">如果左側為 <code>true</code>，則<strong>不判斷</strong>右側值</td><td align="center">如果左側為 <code>false</code>，返回<strong>右側</strong>的<strong>值</strong>，反之亦然</td></tr></tbody></table><p>藉由 JavaScript 任何型別都能轉換成<strong>布林值</strong>，會先轉換成布林值再進行邏輯判斷。<br>如果是使用 <code>!</code> 返回的會是布林值，而 <code>&amp;&amp;</code> 和 <code>∣∣</code> 返回的是原本的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">let</span> c = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> d;<br><span class="hljs-built_in">console</span>.log( a &amp;&amp; b ); <span class="hljs-comment">// &quot;abc&quot;    　左側為 ture ，返回右側值</span><br><span class="hljs-built_in">console</span>.log( a || b ); <span class="hljs-comment">// 123        左側為 ture ，判斷中斷，直接返回左側值</span><br><span class="hljs-built_in">console</span>.log( c &amp;&amp; b ); <span class="hljs-comment">// null       左側為 false，判斷中斷，直接返回左側值</span><br><span class="hljs-built_in">console</span>.log( c || b ); <span class="hljs-comment">// &quot;abc&quot;      左側為 false，返回右側值</span><br><span class="hljs-built_in">console</span>.log( c &amp;&amp; d ); <span class="hljs-comment">// null       左側為 false，判斷中斷，直接返回左側值</span><br><span class="hljs-built_in">console</span>.log( c || d ); <span class="hljs-comment">// undefined  左側為 false，返回右側值</span><br></code></pre></td></tr></table></figure><h2 id="賦值運算子"><a href="#賦值運算子" class="headerlink" title="賦值運算子"></a>賦值運算子</h2><table><thead><tr><th align="center">運算符</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center">最基本的賦值</td></tr><tr><td align="center"><code>+=</code></td><td align="center"><code>a = a + 2</code> 與 <code>a += 2</code> 一樣</td></tr><tr><td align="center"><code>-=</code></td><td align="center"><code>a = a - 2</code> 與 <code>a -= 2</code> 一樣</td></tr><tr><td align="center"><code>*=</code></td><td align="center"><code>a = a * 2</code> 與 <code>a *= 2</code> 一樣</td></tr><tr><td align="center"><code>/=</code></td><td align="center"><code>a = a / 2</code> 與 <code>a /= 2</code> 一樣</td></tr><tr><td align="center"><code>%=</code></td><td align="center"><code>a = a % 2</code> 與 <code>a %= 2</code> 一樣</td></tr></tbody></table><p>最基礎的 <code>=</code> 就是賦值語句，把右側的值，賦值給左側的變數。<br>而 <code>=</code> 左側添加算術運算子，能有效把原本比較長的運算式簡化。</p><h2 id="比較運算子"><a href="#比較運算子" class="headerlink" title="比較運算子"></a>比較運算子</h2><table><thead><tr><th align="center">運算符</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center"><code>&gt;</code></td><td align="center">是否大於</td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">是否小於</td></tr><tr><td align="center"><code>&gt;=</code></td><td align="center">是否大於等於</td></tr><tr><td align="center"><code>&lt;=</code></td><td align="center">是否小於等於</td></tr><tr><td align="center"><code>==</code></td><td align="center">是否相等</td></tr><tr><td align="center"><code>!=</code></td><td align="center">是否不相等</td></tr><tr><td align="center"><code>===</code></td><td align="center">是否全等</td></tr><tr><td align="center"><code>!==</code></td><td align="center">是否不全等</td></tr></tbody></table><p>用來進行比較的運算子，就跟數學課的比大小一樣。<br>比較運算子會對兩側值進行比對，返回的會是布林值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>;       <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>;       <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-number">1</span>;      <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="相等-與-全等-的差別"><a href="#相等-與-全等-的差別" class="headerlink" title="== 相等 與 === 全等 的差別"></a><code>==</code> 相等 與 <code>===</code> 全等 的差別</h3><p>簡單來說，<code>==</code> 比較時 JavaScript 會自動幫你<strong>轉型</strong>進行比對，而 <code>===</code> 則是進行<strong>嚴格比對</strong>，不會自動轉型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>;    <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> === <span class="hljs-string">&quot;1&quot;</span>;   <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> != <span class="hljs-string">&quot;1&quot;</span>;    <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> !== <span class="hljs-string">&quot;1&quot;</span>;   <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-number">0</span>;  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="比較運算子中的特例！-NaN"><a href="#比較運算子中的特例！-NaN" class="headerlink" title="比較運算子中的特例！ NaN"></a>比較運算子中的特例！ NaN</h3><p>在所有型別中，數字型別的 NaN 非常特別，NaN 不管跟誰比對，都是回傳 false，<strong>包括</strong>他跟自己比對也是。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>;  <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> != <span class="hljs-literal">NaN</span>;  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>一開始我也以為邏輯運算子返回的都是布林值，但實際返回的並不一定是布林值，因為這個特性，讓我們在撰寫 JavaScript 會更加彈性好運用來取得我們所想要的值。<br>我們現在已學會了基本的<strong>宣告變數</strong>與<strong>基礎型別</strong>，也學會了<strong>基礎的運算子</strong>，接著我們就能利用目前所學的東西，來學習如何讓程式語言幫我進行條件判斷！下一個章節就來介紹<strong>條件判斷式</strong>！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.13 「初步學習 JavaScript 基礎篇」 —— JavaScript 宣告變數 與 基本型別</title>
    <link href="/2021/09/22/2021-9-22-it_ironman-day13/"/>
    <url>/2021/09/22/2021-9-22-it_ironman-day13/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-13-「初步學習-JavaScript-基礎篇」-——-JavaScript-宣告變數-與-基本型別"><a href="#Day-13-「初步學習-JavaScript-基礎篇」-——-JavaScript-宣告變數-與-基本型別" class="headerlink" title="Day.13 「初步學習 JavaScript 基礎篇」 —— JavaScript 宣告變數 與 基本型別"></a>Day.13 「初步學習 JavaScript 基礎篇」 —— JavaScript 宣告變數 與 基本型別</h1><p><img src="https://i.imgur.com/wh1ZT6h.png" alt="JavaScript 宣告變數 與 基本型別"></p><p>前面已經大略介紹了 HTML 和 CSS 的入門知識了，接著我們要來認識 JavaScript，來為我們的網頁添加更多邏輯互動。</p><h2 id="怎麼宣告變數？"><a href="#怎麼宣告變數？" class="headerlink" title="怎麼宣告變數？"></a>怎麼宣告變數？</h2><p>JavaScript 是個<strong>弱型別</strong>語言，在宣告變數時，不像其他語言需要先指定型別那麼嚴謹，宣告的<strong>變數名</strong>會對應<strong>記憶體位子</strong>，把其<strong>值</strong>存入<strong>記憶體中</strong>，之後要取出值，只要藉由變數名，就能找到對應的值。</p><p><img src="https://i.imgur.com/J6BjmqI.png" alt="宣告變數"><br><img src="https://i.imgur.com/SAFuUzt.png" alt="存入記憶體中"></p><p>要幫變數命名也是有規則的，首先<strong>保留字</strong>（如：<code>class</code>）與<strong>關鍵字</strong>（如：<code>var</code>），不能用於變數名，變數名<strong>不能由數字作為開頭</strong>，且變數名有<strong>大小寫之分</strong>，可以使用<code>$</code>、<code>_</code>在名稱中。常見的命名法為<strong>駝峰命名法</strong>，如：<code>petName</code>、<code>pet_name</code>。</p><p>目前宣告方式有 3 個（含 ES6）</p><blockquote><p>什麼是 ES6？ ES6 正式名稱為 ECMAScript 2015，是第<strong>六</strong>版 ECMAScript，因此簡稱 ES6。<br>ES6 增加了原本 JavaScript 沒有的語法，能更加方便使用與維護，但有些瀏覽器兼容性可能不好（<del>如：IE</del>）</p></blockquote><ul><li><code>var</code>，JavaScript 最原始的宣告方法，使用起來很簡單暴力，屬於<strong>全域宣告</strong>，可以在<strong>函式作用域</strong>做區隔，因為容易汙染全域變數，所以目前比較少使用了。</li><li><code>let</code>，ES6 新增的宣告方法，<code>let</code> 與 <code>var</code> 最大的不同就是<strong>區域作用域（block scope）</strong>，比較不會有汙染問題。</li><li><code>const</code>，ES6 新增的宣告方法，<code>const</code> 最大的特色是屬於<strong>常數宣告</strong>，常數宣告的意思是不能隨意改值，降低不小心更改所導致的 bug，<strong>需注意</strong> 因為是常數宣告，無法隨意改值，所以使用常數宣告<strong>一定要賦予值</strong>，否則會報錯。</li></ul><blockquote><p>何謂常數？ 就像是圓周率 π 就是數學常數 3.14159，並不會隨意更改。</p></blockquote><h2 id="變數的基本型別"><a href="#變數的基本型別" class="headerlink" title="變數的基本型別"></a>變數的基本型別</h2><p>JavaScript 的基本型別</p><ul><li><p>string 字串型別，這個型別很簡單，只要是使用 <code>&quot;</code> 、 <code>&#39;</code> 包起來的就是字串型別，另外 ES6 還新增了樣板字面值 <code>‵</code>，使用起來更加方便靈活，還能套用變數，<strong>注意</strong> 包起來的符號要一樣的才可以。</p><ul><li><code>&quot;string&quot;</code> 頭尾都是使用 <code>&quot;</code></li><li><code>&#39;string&#39;</code> 頭尾都是使用 <code>&#39;</code></li><li><code>&#39;string&quot;</code> 交錯使用會<strong>報錯</strong>。</li><li>如果字串內要使用 <code>&#39;</code> 則需要使用 <code>&quot;</code> 來包，如：<code>&quot;I&#39;m Mao&quot;</code>，反之亦然。</li><li>ES6 新增的樣板字面值，<code>‵string $&#123; 變數名 &#125;‵</code> 頭尾都使用 <code>‵</code>，要使用變數可以在裡面使用 <code>$&#123;&#125;</code> 來使用。</li></ul></li><li><p>number 數字型別，這個型別代表數字，以下這些都是數字型別</p><ul><li>不管是正負數、小數點都是。（如：0, 9, -8, 7.6）</li><li><code>Infinity</code>（無限大）</li><li><code>-Infinity</code>（無限小）</li><li><code>NaN</code>（Not a Number，非數字）</li></ul></li><li><p>boolean 布林值，這個值就非常的單純許多，只有 true 與 false，這兩個值，主要是使用在判斷式中，在 Javascript 中，<strong>任何值都能轉換成布林值</strong>。</p></li><li><p>undefined 未定義型別，只有一個值 undefined，代表這個變數<strong>還沒定義型別</strong>。</p></li><li><p>null 空值，只有一個值 null ，代表這個變數<strong>目前定義為沒有值</strong>。</p></li><li><p>object 以上基本型別以外的都是<strong>Object 物件</strong>，物件這個東西比較複雜，我們之後在細細品味。</p></li></ul><h2 id="如何知道變數的型別？"><a href="#如何知道變數的型別？" class="headerlink" title="如何知道變數的型別？"></a>如何知道變數的型別？</h2><p>可以使用 JavaScript 中用來判斷型別的運算符 <code>typeof</code>，使用方法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">let</span> n = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;I&#x27;m Mao&quot;</span>; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>;       <span class="hljs-comment">// number</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>;      <span class="hljs-comment">// boolean</span><br><span class="hljs-keyword">typeof</span> a;         <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">typeof</span> n;         <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;;        <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> [];        <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>欸～這時會發現奇怪的事情，null 給出的型別怎麼是 object 呢？ 這其實是一開始 Javascript 設置實作時產生的 bug！</p><blockquote><p>JavaScript 的值是由一個表示<strong>型別</strong>的標籤，與實際內容的<strong>值</strong>所組成。<br>由於物件型別標籤是 <strong>0</strong>，而 null 代表的是空值（通常以 0x00 表示），導致物件與空值的標籤搞混，而產生的結果。<br>內容取自 <a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></p></blockquote><p>既然 JavaScript 已經不打算修復這個 bug 了（應該說一改會牽動到很多東西，就乾脆不改了），我們就 <del>想像 null 是空物件吧</del>，實際上並不是唷！</p><h3 id="如何分辨-NaN"><a href="#如何分辨-NaN" class="headerlink" title="如何分辨 NaN"></a>如何分辨 NaN</h3><p>這時會很困擾，會發現一般數字與 NaN 檢查型別都是回傳 number，要判斷數字型別是否為 NaN。<br>可以利用 JavaScript 提供的 <code>isNaN()</code> 來進行判斷！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-literal">NaN</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">isNaN</span>(n) );  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="如何轉型別？"><a href="#如何轉型別？" class="headerlink" title="如何轉型別？"></a>如何轉型別？</h2><p>有的時候我們宣告變數使用<code>var a = &quot;1&quot;</code>，那麼 <code>a</code> 是的型別是什麼？ 聰明的你應該馬上就知道是字串（string）型別了吧！<br>那麼如果想要把 <code>a</code> 轉型成數字（number）型別，就可以使用轉換型別的語法，剛好來介紹一下轉換型別的語法吧！</p><p>轉換型別語法：</p><ul><li>轉換成字串（string）型別：<ul><li><code>toString()</code>，使用方法<code>a.toString()</code>就能轉換成字串型別，但遇到 null 或 undefined <strong>會報錯</strong></li><li><code>String()</code>，使用方法<code>String(a)</code>就能轉換成字串型別，遇到 null 或 undefined <strong>也不會報錯</strong></li><li>變數直接加空字串，使用方法 <code>a + &#39;&#39;</code> 就能轉換成字串型別。</li></ul></li><li>轉換成數字型別<ul><li><code>Number()</code>，任意資料型別轉換成數字型別。</li><li><code>parseInt()</code>，將字串或數字轉成整數。</li><li><code>parseFloat()</code>，將字串或數字轉成浮點數。</li><li>變數前面使用 <code>+</code> 一元運算子 或後面使用 <code>*1</code>，使用方法 <code>+a</code> 或 <code>a *1</code> 就能轉換成數字型別。</li></ul></li><li>任何型別都可以轉換成 <strong>布林值</strong><ul><li>true<ul><li>任何非空字串的值</li><li>任何非 0 的數字</li><li>任何物件</li></ul></li><li>false<ul><li>空字串（<code>&#39;&#39;</code> 和 <code>&quot;&quot;</code>）</li><li>數字 0 和 NaN</li><li>null 和 undefined</li></ul></li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>終於開始學習程式語言了，今天認識了基礎的宣告變數與型別判斷，蠻推薦 Kuro 大大寫的 <a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a>，寫得十分有趣清楚，下一篇章先進入我們的運算符篇。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tenlong.com.tw/products/9789864344130">008 天 重新認識 JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.12 「來為網頁添加動畫吧！」 —— CSS 動畫（animation）</title>
    <link href="/2021/09/21/2021-9-21-it_ironman-day12/"/>
    <url>/2021/09/21/2021-9-21-it_ironman-day12/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-12-「來為網頁添加動畫吧！」-——-CSS-動畫（animation）"><a href="#Day-12-「來為網頁添加動畫吧！」-——-CSS-動畫（animation）" class="headerlink" title="Day.12 「來為網頁添加動畫吧！」 —— CSS 動畫（animation）"></a>Day.12 「來為網頁添加動畫吧！」 —— CSS 動畫（animation）</h1><p><img src="https://i.imgur.com/Z0lYvKC.gif" alt="「來為網頁添加動畫吧！」 —— CSS 動畫（animation）"></p><p>現在我們會使用具有互動性的簡單漸變效果了，接著要來試著讓網頁能增添更多活力，不需要我們操作，就會自動播放動畫效果。</p><h2 id="什麼是-animation？"><a href="#什麼是-animation？" class="headerlink" title="什麼是 animation？"></a>什麼是 animation？</h2><p>animation 就如同字面上的意思，動畫賦予了 CSS 更多的可能性，讓畫面可以更加生動活潑，以往要透過 Javascript 才能完成的效果，如今 CSS 也能幫忙分擔一些畫面效果，記住一句話，能使用 CSS 完成效果，就盡量使用 CSS。</p><h2 id="CSS-animation-起手式"><a href="#CSS-animation-起手式" class="headerlink" title="CSS animation 起手式"></a>CSS animation 起手式</h2><h3 id="關鍵影格-keyframes"><a href="#關鍵影格-keyframes" class="headerlink" title="關鍵影格 keyframes"></a>關鍵影格 keyframes</h3><p>一開始的起手式當然就是先定義一個動畫效果，使用方法為<code>@keyframes &lt;name&gt; &#123; animation_css &#125;</code>，有在製作動畫影片的應該對 keyframes（關鍵影格） 這個字非常熟悉，藉由著個語法，來讓瀏覽器運算產生動態畫面，其中<code>&lt;name&gt;</code>可以自定義動畫名稱，<code>&#123;&#125;</code>內為動畫執行過程，執行過程可以用 <code>0%</code> ～ <code>100%</code>，或使用關鍵字 <code>from</code> &amp; <code>to</code>。</p><p>例如，想讓封面圖的方塊旋轉，可以使用上一章的 <code>transform: rotateY()</code> 依靠 Y 軸為軸心進行旋轉：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> rotate &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">360deg</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="套用-CSS-animation"><a href="#套用-CSS-animation" class="headerlink" title="套用 CSS animation"></a>套用 CSS animation</h2><h3 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h3><p>動畫名稱，<strong>注意</strong> 這個一定要設置，不然瀏覽器不知道你要套用的動畫名稱是什麼，<del>除非它會通靈</del>，以上面關鍵影格為例<code>animation-name: rotate;</code></p><h3 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h3><p>動畫動完一次所需時間，<strong>注意</strong> 這個也一定要設置，因為預設是 0，<del>不會動的動畫還叫動畫</del>？以上面關鍵影格為例<code>animation-duration: 5s;</code>，需 <strong>注意</strong> 單位名稱一定要打，s 代表 秒，ms 代表 毫秒。</p><h3 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h3><p>動畫延遲多久時間開始播放，這個看需求設置，與上面的設定方法雷同。</p><h3 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h3><p>動畫循環幾次，這個也是看需求設置，預設是 1，執行 1 次的意思。</p><h4 id="想要無限循環多次？"><a href="#想要無限循環多次？" class="headerlink" title="想要無限循環多次？"></a>想要無限循環多次？</h4><p>想要無限循環多次，可以設定 <code>infinite</code>，以上面關鍵影格為例<code>animation-iteration-count: infinite;</code></p><h3 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h3><p>動畫加速度的函式，預設是 <code>ease</code></p><p><img src="https://i.imgur.com/j0hxXeA.gif" alt="animation-time-function"><br><a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/vYZjYZQ?editors=0100">animation-time-function Codepen</a></p><h4 id="具有加減速的速度函式"><a href="#具有加減速的速度函式" class="headerlink" title="具有加減速的速度函式"></a>具有加減速的速度函式</h4><p>這個動態效果比較流暢</p><ul><li>ease</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li></ul><p><img src="https://www.oxxostudio.tw/img/articles/201803/css-animation-04.jpg" alt="具有加減速的速度函式圖"><br>（<a href="https://www.oxxostudio.tw/articles/201803/css-animation.html">圖片來源</a>）</p><h4 id="線性速度函式"><a href="#線性速度函式" class="headerlink" title="線性速度函式"></a>線性速度函式</h4><p>不具有加減速</p><ul><li>linear 線性，此封面範例就是使用這個 <code>animation-time-function: linear;</code></li></ul><p><img src="https://www.oxxostudio.tw/img/articles/201803/css-animation-03.jpg" alt="線性函式圖"><br>（<a href="https://www.oxxostudio.tw/articles/201803/css-animation.html">圖片來源</a>）</p><h4 id="影格速度函式"><a href="#影格速度函式" class="headerlink" title="影格速度函式"></a>影格速度函式</h4><p>就像膠片影格一樣，一步一步展示變化過程，int 設置正整數，數字越大越流暢。<br>第二個參數，start 會忽略第 0 秒的開始動畫，end 會忽略最後一秒的結束動畫</p><ul><li>steps(int,start/end)</li></ul><h4 id="自定義速度函式（貝茲曲線）"><a href="#自定義速度函式（貝茲曲線）" class="headerlink" title="自定義速度函式（貝茲曲線）"></a>自定義速度函式（貝茲曲線）</h4><p>這就比較複雜了，由四個參數來設置貝茲曲線，設置的好會像皮球彈跳一樣自然來回，<del>設置不好就會失控</del>。</p><ul><li>cubic-bezier(n,n,n,n)</li></ul><h3 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h3><p>控制動畫是否反轉播放，預設值為 <code>normal</code> 正常播放</p><ul><li>normal，正常播放</li><li>reverse：反轉播放，從 100% 到 0% 反著播。</li><li>alternate：上面兩個的結合，正反播放輪替，先正後反，如此循環，當播放次數設 1 時，就正常播放</li><li>alternate-reverse：與 alternate 的相反，變成先反後正，當播放次數設 1 時，就反轉播放</li></ul><p><img src="https://i.imgur.com/pBGvsjp.gif" alt="此圖範例為使用 animation-directon: alternate;"><br><em>此圖範例為使用 <code>animation-direction: alternate;</code>，<a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/wvejaWj">Codepen</a></em></p><h2 id="簡寫方式"><a href="#簡寫方式" class="headerlink" title="簡寫方式"></a>簡寫方式</h2><p>根據上面封面的動畫效果，原本是這樣使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation-name</span>: rotate;<br><span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">5s</span>;<br><span class="hljs-attribute">animation-iteration-count</span>: infinite;<br><span class="hljs-attribute">animation</span>-<span class="hljs-selector-tag">time</span>-function: linear;<br></code></pre></td></tr></table></figure><p>可以看到一直反覆的寫 <code>animation-</code> 開頭，而簡寫方式非常簡單</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">5s</span> infinite linear;<br></code></pre></td></tr></table></figure><p>直接用 <code>animation</code> 就可以設定所有動畫設定了，需<strong>注意</strong> 動畫<strong>名稱</strong> 與 <strong>時間</strong> 是一定要寫的，如果要設置 delay，第一個時間參數會是 持續時間，第二個時間參數會是 延遲時間！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>平面動畫寫起來還算簡單，很有成就感，如果要涉及到 3D 層面的話，又會需要多設定一些東西，如同前一篇所講，視角與定位點，會更加抽象，現階段 CSS 已經告個段落了！明天就要進入我們的 Javascript 章節了！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.oxxostudio.tw/articles/201803/css-animation.html">完整解析 CSS 動畫</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.11 「利用漸變效果，讓網頁不再死板！」 —— CSS Transform &amp; CSS Transition</title>
    <link href="/2021/09/20/2021-9-20-it_ironman-day11/"/>
    <url>/2021/09/20/2021-9-20-it_ironman-day11/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-11-「利用漸變效果，讓網頁不再死板！」-——-CSS-Transform-amp-CSS-Transition"><a href="#Day-11-「利用漸變效果，讓網頁不再死板！」-——-CSS-Transform-amp-CSS-Transition" class="headerlink" title="Day.11 「利用漸變效果，讓網頁不再死板！」 —— CSS Transform &amp; CSS Transition"></a>Day.11 「利用漸變效果，讓網頁不再死板！」 —— CSS Transform &amp; CSS Transition</h1><p><img src="https://i.imgur.com/VoFpU6Q.png" alt="「利用漸變效果，讓網頁不再死板！」 —— CSS Transform &amp; CSS Transition"></p><p>現在我們會使用基本的偽類選擇器做效果了，但看到變化過程一閃而過、冷冰冰的，想增添更多漸變效果，讓動態效果可以更多變化、更平滑動感，就要使用我們的 transform 與 transition 這兩個屬性。</p><h2 id="transform-是做什麼的？"><a href="#transform-是做什麼的？" class="headerlink" title="transform 是做什麼的？"></a>transform 是做什麼的？</h2><p>transform 屬性是依靠 <strong>GPU</strong> 控制，修改 CSS 視覺模型的<strong>空間維度</strong>。</p><p>大多數的屬性值預設都是操控平面維度的 <strong>X 軸</strong> 與 <strong>Y 軸</strong>，如果要再加上第三維度 <strong>Z 軸</strong>，需要額外添加。</p><p>使用方法為<code>transform: 想進行控制的屬性值方法</code>，有多個屬性值可以用空白鍵或換行做區隔。</p><p>以下的動態圖，只是要區分元素與原本的差異，並不會有動態效果</p><h3 id="進行平移的屬性值-translate"><a href="#進行平移的屬性值-translate" class="headerlink" title="進行平移的屬性值 translate"></a>進行平移的屬性值 translate</h3><p>你會發現跟 <strong>Position 定位元素</strong>很相似，同樣都是移動元素，但他們不同的地方是，% 數參考的對象 與 GPU 的參與。<strong>注意</strong> 適當使用 GPU 可以減輕渲染負擔，過度使用 GPU 容易消耗過多記憶體。<br><img src="https://i.imgur.com/nRz9ajW.gif" alt="translate"></p><ul><li>在執行<strong>動畫效果</strong>時，Position 定位會觸發瀏覽器的 reflow 和 repaint，讓瀏覽器一直重新渲染畫面，動畫效果也因為最小單位 1px，感覺有一點卡卡的感覺。<br><img src="https://i.imgur.com/DadHR9C.gif" alt="瀏覽器一直頻繁的 reflow 和 repaint"><br><em>瀏覽器一直頻繁的 reflow 和 repaint</em></li><li>而使用 translate 平移執行動畫，則是透過 GPU 來控制，使用硬體加速，動畫效果也比較平順。<br><img src="https://i.imgur.com/sVx7wS3.gif" alt="依靠 GPU 不會觸發瀏覽器的 reflow 和 repaint"><br><em>依靠 GPU 不會觸發瀏覽器的 reflow 和 repaint</em></li></ul><p>使用方法<code>transform: translate( X 軸, Y 軸 )</code>，當只有使用一個值，該值代表 X 軸，如果想使用 Z 軸，就要改用<code>translate3d(X 軸, Y 軸, Z 軸 )</code> 或 <code>translateZ( Z 軸 )</code>。</p><p>使用的值需要單位（px, %, em…），% 數是依照<strong>自身長寬</strong>當作參考，<strong>Z 軸只能使用長度單位</strong>（px, em…），因為深度沒有 % 數。</p><h3 id="進行縮放的屬性值-scale"><a href="#進行縮放的屬性值-scale" class="headerlink" title="進行縮放的屬性值 scale"></a>進行縮放的屬性值 scale</h3><p>同樣會發現與 <strong>寬高元素（height、width）</strong> 很相似，而不同的地方也如同上面的例子。<br><img src="https://i.imgur.com/mj3YMpu.gif" alt="scale"></p><p>使用方法<code>transform: scale( X 軸, Y 軸 )</code>，當只有使用一個值，該值代表整體的放大縮小，如果想使用 Z 軸，就要改用<code>scale3d(X 軸, Y 軸, Z 軸 )</code> 或 <code>scaleZ( Z 軸 )</code>。</p><p>使用的值為數字，<code>1</code> 為 1 倍大小，<code>.8</code> 為 0.8 倍大小</p><h3 id="進行旋轉的屬性值-rotate"><a href="#進行旋轉的屬性值-rotate" class="headerlink" title="進行旋轉的屬性值 rotate"></a>進行旋轉的屬性值 rotate</h3><p>讓元素進行旋轉<br><img src="https://i.imgur.com/tJtkM2T.gif" alt="rotate"></p><p>使用方法<code>transform: rotate( Z 軸 )</code>，依靠 <strong>Z 軸</strong>旋轉，如果想依靠 X 軸 或 y 軸，就要改用<code>rotateX( X 軸 )</code> 或 <code>rotateY( Y 軸 )</code>。</p><p>使用的值需要單位</p><ul><li>deg（一個圓有 360 度），應該是最多人用的</li><li>gard（一個圓有 400 個梯度）</li><li>rad（一個圓有 2π 弧度）</li><li>turn（一個圓）</li></ul><p>另外也可以使用 <code>rotate3d( X 軸, Y 軸, Z 軸, 角度)</code>，其中 XYZ 軸為<strong>倍數</strong>，每個倍數乘以角度來呈現。</p><h3 id="進行傾斜的屬性值-skew"><a href="#進行傾斜的屬性值-skew" class="headerlink" title="進行傾斜的屬性值 skew"></a>進行傾斜的屬性值 skew</h3><p>讓元素沿著軸線傾斜<br><img src="https://i.imgur.com/AOmufkr.gif" alt="skew"></p><p>使用方法<code>transform: skew( X 軸, Y 軸 )</code>，當只有使用一個值，該值代表 X 軸，傾斜沒有 Z 值。</p><h3 id="變形矩陣的屬性值-matrix"><a href="#變形矩陣的屬性值-matrix" class="headerlink" title="變形矩陣的屬性值 matrix"></a>變形矩陣的屬性值 matrix</h3><p>算是綜合了上面的平移、縮放與傾斜的語法。<br>語法：<code>matrix(X 軸縮放, X 軸平移, X 軸傾斜, Y 軸縮放, Y 軸平移, Y 軸傾斜)</code><br>我個人是不常用，參數太多容易搞混。</p><h2 id="恭喜你又學會新的置中方法了"><a href="#恭喜你又學會新的置中方法了" class="headerlink" title="恭喜你又學會新的置中方法了"></a>恭喜你又學會新的置中方法了</h2><p>前面在 Position 定位章節有提到，用 Position 定位置中 <code>top: 50%; left: 50%;</code> 會因為元素基準點是在左上角，導致左上角定位在中心，元素整體會呈現偏右下方。</p><p>這時藉由 <code>transform: translate(-50%, -50%);</code>，因為 % 數是參考自身長寬，藉由 <code>-50%</code> 來矯正偏移問題，讓元素呈現完美的置中。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實 transform 還有很多屬性方法還沒介紹，像是設定<strong>基準點</strong>、<strong>定位視角</strong>，這類更為抽象進階的語法，也許會放到之後補充的地方，今天就先介紹簡單常用入門的部分就好，下一個章節算是大家學 CSS 最想達成的<strong>動畫</strong>章節。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.796t.com/article.php?id=313455">淺析 CSS 的效能優化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.10 「沒有 RWD 的網站 === 沒有未來」 —— RWD　響應式網頁設計</title>
    <link href="/2021/09/19/2021-9-19-it_ironman-day10/"/>
    <url>/2021/09/19/2021-9-19-it_ironman-day10/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-10-「沒有-RWD-的網站-沒有未來」-——-RWD-響應式網頁設計"><a href="#Day-10-「沒有-RWD-的網站-沒有未來」-——-RWD-響應式網頁設計" class="headerlink" title="Day.10 「沒有 RWD 的網站 === 沒有未來」 —— RWD　響應式網頁設計"></a>Day.10 「沒有 RWD 的網站 === 沒有未來」 —— RWD　響應式網頁設計</h1><p><img src="https://i.imgur.com/tJZ3MrQ.png" alt="「沒有 RWD 的網站 === 沒有未來」 —— RWD　響應式網頁設計"></p><p>雖然標題有點聳動，但在這個行動裝置越來越多的現在，如果沒有<strong>手機版的網頁</strong>，<strong>SEO</strong> 排名會大受影響，也等同於宣告死刑了。</p><p><img src="https://i.imgur.com/ruLsPM4.png" alt="沒有手機版網頁，使用者體感差，字小按鈕也很難點"></p><h2 id="什麼是-RWD？"><a href="#什麼是-RWD？" class="headerlink" title="什麼是 RWD？"></a>什麼是 RWD？</h2><p>是 Responsive Web Design 的簡稱 RWD，中文翻譯為<strong>響應式網頁設計</strong>，主要是針對不同裝置，網頁透過裝置寬度來決定排版的方式。</p><p><img src="https://i.imgur.com/Uyp0Xl3.gif" alt="隨著裝置不同，布局也不同"></p><h2 id="RWD-要如何開始？"><a href="#RWD-要如何開始？" class="headerlink" title="RWD 要如何開始？"></a>RWD 要如何開始？</h2><h3 id="1-在-HTML-添加-viewport-的-meta-標籤"><a href="#1-在-HTML-添加-viewport-的-meta-標籤" class="headerlink" title="1. 在 HTML 添加 viewport 的 meta 標籤"></a>1. 在 HTML 添加 viewport 的 meta 標籤</h3><p>首先要在 HTML 檔案 <code>&lt;head&gt;</code> 標籤內添加 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code>，通常使用 emmet 會自動設定。<br>viewport 屬性值：</p><ul><li>width=device-width：寬度等於當前裝置的寬度</li><li>height=device-height：高度等於當前裝置的高度</li><li>initial-scale：初始的縮放比例</li><li>minimum-scale：允許使用者縮放到的最小比例</li><li>maximum-scale：允許使用者縮放到的最大比例</li><li>user-scalable：使用者是否可以手動縮放</li></ul><h3 id="2-決定設計模式"><a href="#2-決定設計模式" class="headerlink" title="2. 決定設計模式"></a>2. 決定設計模式</h3><ul><li>局部流動 (mostly fluid)，隨著螢幕寬度斷點，主體像流體般依序往下排列。</li><li>欄內容下排 (column drop)，最大寬度時呈現橫向排列，隨著螢幕斷點往下推擠排列。</li><li>版面配置位移 (layout shifter)，隨著螢幕寬度斷點，進行版面大幅配置改變。</li><li>細微調整 (tiny tweaks)，隨著螢幕寬度，微小調整字體大小與按鈕大小 。</li><li>畫布外空間利用 (off canvas)，以橫向卷軸來操作，在小螢幕時顯示滿版，大螢幕時會排進更多畫面，有點像<strong>簡報</strong>。</li></ul><p>想更詳細的介紹可以看<a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive/patterns?hl=zh-tw">回應式網頁設計模式</a></p><h3 id="3-使用-CSS-media-query-設定"><a href="#3-使用-CSS-media-query-設定" class="headerlink" title="3. 使用 CSS media query 設定"></a>3. 使用 CSS media query 設定</h3><p>使用方法在 CSS 檔案內需用<code>@media (條件) &#123;樣式&#125;</code>來設定，需要<strong>注意</strong>要寫在下方</p><p>例如想設定當視窗<strong>寬度小於</strong> 768px，改變背景顏色，語法範例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-comment">/*  當視窗寬度 大於 768px 省略這段 CSS  */</span><br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#88f</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/i7aU70Q.gif" alt="RWD 效果"><br><img src="https://i.imgur.com/zxzxCoj.png" alt="開發者工具可以看出，當螢幕小於 768px 原本樣式被覆蓋"></p><p>如果要改成<strong>大於</strong> 768px，才觸發樣式，就把條件設成<code>(min-width: 768px)</code></p><h3 id="4-使用相對單位設定大小"><a href="#4-使用相對單位設定大小" class="headerlink" title="4. 使用相對單位設定大小"></a>4. 使用相對單位設定大小</h3><p>此外會建議多使用相對單位設定樣式（%），比較不會出現字太小或按鈕太小的問題。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我們已經大致上了解了 RWD 的設置，接著就是持續的實作才能掌握它，想了解更詳細的設定模式，可以看<a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive/patterns?hl=zh-tw">回應式網頁設計模式</a>，下一個章節將會介紹 CSS transform。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive/patterns?hl=zh-tw">回應式網頁設計模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.9 「我介於有與沒有之間～」 —— CSS 偽類選擇器（Pseudo classes） 與 偽元素（Pseudo element）</title>
    <link href="/2021/09/18/2021-9-18-it_ironman-day9/"/>
    <url>/2021/09/18/2021-9-18-it_ironman-day9/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-9-「我實際不存在-DOM-裡～」-——-CSS-偽類選擇器（Pseudo-classes）-與-偽元素（Pseudo-element）"><a href="#Day-9-「我實際不存在-DOM-裡～」-——-CSS-偽類選擇器（Pseudo-classes）-與-偽元素（Pseudo-element）" class="headerlink" title="Day.9 「我實際不存在 DOM 裡～」 —— CSS 偽類選擇器（Pseudo classes） 與 偽元素（Pseudo element）"></a>Day.9 「我實際不存在 DOM 裡～」 —— CSS 偽類選擇器（Pseudo classes） 與 偽元素（Pseudo element）</h1><p><img src="https://i.imgur.com/77yUxJL.png" alt="「我實際不存在 DOM 裡～」 —— CSS 偽類選擇器（Pseudo classes） 與 偽元素（Pseudo element）"></p><h2 id="為什麼會有個「偽」字呢？"><a href="#為什麼會有個「偽」字呢？" class="headerlink" title="為什麼會有個「偽」字呢？"></a>為什麼會有個「偽」字呢？</h2><p>偽（Pseudo）這個意思有虛幻虛無的意思，類選擇器是用來處理 DOM 操作不了選擇器，偽元素則是原本並沒有在 HTML DOM 中，是透過 CSS 創造出來的元素。</p><h2 id="什麼是偽類選擇器（Pseudo-classes）？"><a href="#什麼是偽類選擇器（Pseudo-classes）？" class="headerlink" title="什麼是偽類選擇器（Pseudo classes）？"></a>什麼是偽類選擇器（Pseudo classes）？</h2><p>前面篇章有提到 CSS 選擇器，通常都能單獨使用，而偽類選擇器比較特別，他<strong>必須</strong>搭配其他選擇器來使用，我們常使用的<strong>操作型偽類</strong>在<strong>觸發條件前</strong>，一切都是假的！平時並不會有效果，最常見的範例就是<code>&lt;a&gt;</code>標籤。</p><h2 id="偽類選擇器"><a href="#偽類選擇器" class="headerlink" title="偽類選擇器"></a>偽類選擇器</h2><p>這邊將舉出最常見的偽類選擇器與使用方法，還有許多偽類選擇器可以查看 MDN 官方文件<br>使用方法需在前面加<code>:</code>前綴，以<code>&lt;a&gt;</code>標籤作為範例：<code>a:hover &#123; css... &#125;</code></p><h3 id="操作型偽類"><a href="#操作型偽類" class="headerlink" title="操作型偽類"></a>操作型偽類</h3><ul><li><p><code>:hover</code>，當游標懸浮在元素上時，產生效果，最常見的使用方式。</p><p><a href="#">游標懸浮在我上面，我顏色會變</a></p></li><li><p><code>:active</code>，當游標對著元素壓住時，產生效果，通常使用在按鈕類型的元件。</p></li><li><p><code>:focus</code>，當元素是焦點狀態時，產生效果，通常都是使用在<code>&lt;input&gt;</code>輸入框。</p></li></ul><h3 id="結構型偽類"><a href="#結構型偽類" class="headerlink" title="結構型偽類"></a>結構型偽類</h3><ul><li><code>:nth-child()</code>，會根據<code>()</code>條件，影響同級元素樣式的偽類，通常使用在清單、表格這類有規律性的結構做變化。以下範例綠色為有修改樣式，紅色為未修改樣式<ul><li><code>(3)</code>，代表同級元素第三個做樣式。<br><img src="https://i.imgur.com/zkIOMsO.png" alt="nth-child(3)"></li><li><code>(odd)</code>，代表同級元素中的基數列做樣式。<br><img src="https://i.imgur.com/PtKlC8P.png" alt="nth-child(odd)"></li><li><code>(even)</code>代表同級元素中的偶數列做樣式。<br><img src="https://i.imgur.com/dkmyI1M.png" alt="nth-child(even)"></li><li><code>(3n + 1)</code>，代表每 3 個為一組，每組第 1 個做樣式，n 的起始值為 0 。<br><img src="https://i.imgur.com/0vgYHxd.png" alt="nth-child(3n + 1)"></li></ul></li></ul><h2 id="什麼是偽元素（Pseudo-element）？"><a href="#什麼是偽元素（Pseudo-element）？" class="headerlink" title="什麼是偽元素（Pseudo element）？"></a>什麼是偽元素（Pseudo element）？</h2><p>偽元素就更妙了，原本 HTML 結構上沒有，但利用<strong>偽元素</strong>憑空造出一個虛幻的元素，在開發者模式下，只看到<code>::before</code>與<code>::after</code>，到底有還沒有，偽元素的好處就是讓 HTML 結構更加簡單清楚，<del>還感覺自己更厲害了</del>。<br><img src="https://i.imgur.com/fE4Aiv1.png" alt="Pseudo element"></p><h2 id="偽元素"><a href="#偽元素" class="headerlink" title="偽元素"></a>偽元素</h2><p>這邊就舉最常用的兩個偽元素，通常偽元素的使用實際是想讓 HTML 結構更簡單，避免太多<strong>無意義</strong>的標籤。<br>使用方法為需在前面加<code>::</code>前綴，以<code>&lt;div&gt;</code>標籤作為範例：<code>div::after &#123; content: &#39;&#39;; css... &#125;</code>，其中偽元素要添加 <code>content: &#39;&#39;;</code> ，否則沒效果。</p><ul><li><p><code>::after</code>，在元素<strong>後面</strong>安插新的元素，前一篇有介紹<strong>脫離文檔流</strong>的父容器攤縮問題，需使用偽元素（當然還有別的方法，但這個方法比較乾淨），因為在元素<strong>後面</strong>添加新的元素，剛好支撐了父容器的高度以解決攤縮問題，除了解決攤縮問題，還能製作與一般標籤一樣的事情，如下面按鈕淺藍色的部分。</p></li><li><p><code>::before</code>，在元素<strong>前面</strong>安插新的元素，與上一個很相似，只是從元素後面變成元素前面，如下面按鈕藍紫色的部分。</p></li><li><p>偽元素中的 <code>content</code> 是必須要添加的，它代表了偽元素的內容物，通常情況下都是寫一般 string 空字串，當然也有很多值可以寫，但這就需要研究了。</p></li></ul><p>我個人就很喜歡利用偽元素來自製 icon，並透過 CSS 動畫優化。如手機上常出現的<strong>漢堡按鈕</strong>。</p><p><img src="https://i.imgur.com/bTRSASr.png" alt="漢堡按鈕"><br><a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/rNwpLQo?editors=1100">漢堡按鈕 Codepen</a></p><h2 id="屬性選擇器"><a href="#屬性選擇器" class="headerlink" title="屬性選擇器"></a>屬性選擇器</h2><p>選擇器大致上都介紹得差不多了！</p><p>這裡剛好補充一下屬性選擇器，屬性選擇器也有點類似於偽類選擇器，同樣都是要搭配其他選擇器才能使用，不過他是屬於把選擇器條件範圍縮小，平時就有效果了，並不像偽類選擇器平時沒效果。</p><p>因為我平時很少使用，但想說都介紹選擇器了，也覺得屬性選擇器可能有時候有奇效，所以簡單介紹。<br>使用方法是屬性用<code>[key = value]</code>來縮小範圍。</p><ul><li><code>input[type=&quot;checkbox&quot;]</code>，鎖定複選框套入樣式。<br><img src="https://i.imgur.com/zJ8pOOb.png" alt="複選框 套入樣式"></li></ul><p><em>只針對複選框修改寬度高度</em></p><ul><li><code>a[url^=&quot;https://ithelp.ithome.com.tw/&quot;]</code>，選定超連結網址<strong>開頭</strong>是<code>https://ithelp.ithome.com.tw/</code>套入樣式<br><img src="https://i.imgur.com/TavcrpT.png" alt="iT 邦幫忙 連結 套入樣式"><ul><li>條件等於前面加<code>^</code>，表示<strong>開頭</strong>要包含的條件，如<code>url^=https://</code>，網址符合 HTTPS 協定的套入樣式</li><li>條件等於前面加<code>$</code>，表示<strong>結尾</strong>要包含的條件，如<code>src$=&quot;png&quot;</code>，PNG 圖檔的套入樣式</li><li>條件等於前面加<code>*</code>，表示字串中<strong>只要有符合</strong>的條件，如<code>url*=google</code>，網址中有 google 的套入樣式</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從一開始到現在，我們已經把最基礎的切版技能都瞭解了，明天將進入切版重頭戲 RWD 響應式網頁設計章節！</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.8 「怎麼就這樣脫離文檔流了！」 —— CSS 定位屬性 position &amp; 浮動元素 float</title>
    <link href="/2021/09/17/2021-9-17-it_ironman-day8/"/>
    <url>/2021/09/17/2021-9-17-it_ironman-day8/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-8-「怎麼就這樣脫離文檔流了！」-——-CSS-定位屬性-position-amp-浮動元素-float"><a href="#Day-8-「怎麼就這樣脫離文檔流了！」-——-CSS-定位屬性-position-amp-浮動元素-float" class="headerlink" title="Day.8 「怎麼就這樣脫離文檔流了！」 —— CSS 定位屬性 position &amp; 浮動元素 float"></a>Day.8 「怎麼就這樣脫離文檔流了！」 —— CSS 定位屬性 position &amp; 浮動元素 float</h1><p><img src="https://i.imgur.com/n4My3Xy.png" alt="「怎麼就這樣脫離文檔流了！」 —— CSS 定位屬性 position &amp; 浮動元素 float"></p><p>我們已經了解到基本的切版概念了，但前面所學的都是<strong>固定在網頁</strong>上，也就是之前所說正常的<strong>文檔流</strong>！而這一篇就要來學會更進階一點了佈局方法了，讓元素布局上更加奔放自由，<strong>脫離文檔流</strong>。</p><h2 id="脫離文檔流"><a href="#脫離文檔流" class="headerlink" title="脫離文檔流"></a>脫離文檔流</h2><p>之前有大概簡單描述了，<strong>脫離文檔流</strong>，那時候舉的例子是 float ，不過這系列只會簡單迅速介紹 float 浮動元素。<br>而脫離文檔流的副作用就是，父容器因為內容浮動，容易導致無法撐高父容器而塌陷，如下圖父元素只剩文字可以撐高。<br><img src="https://i.imgur.com/a7yWHT2.png" alt="無法撐高"></p><h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>解決父容器塌陷的方法有很多，我這裡簡單舉例大多數人使用的方法，不過提前劇透了下一個篇章的<strong>偽元素</strong>的概念</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 解決塌陷問題 */</span><br><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span> &#123; <span class="hljs-comment">/* 利用 after 偽元素，在元素底下自動撐高 */</span><br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">/* 偽元素要設定 content */</span><br>  <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 變成區塊元素 */</span><br>  <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 清除浮動 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮動元素（float）"><a href="#浮動元素（float）" class="headerlink" title="浮動元素（float）"></a>浮動元素（float）</h2><p>目前 float 浮動元素的主要功能是<strong>文繞圖</strong>功能，其他功能可以使用 position 定位元素搞定了。<br>如同下圖，文字都會繞過圖片，而不會被蓋過去，宛如浮在網頁上，設定值也很簡單：</p><ul><li><code>float: none;</code>，不浮動，預設值</li><li><code>float: left;</code>，向父元素左上側浮動</li><li><code>float: right;</code>，向父元素右上側浮動，如下圖<br><img src="https://i.imgur.com/Ik0RY7c.png" alt="文繞圖"></li></ul><h2 id="定位元素（position）"><a href="#定位元素（position）" class="headerlink" title="定位元素（position）"></a>定位元素（position）</h2><p>定位元素顧名思義，就是在網頁上進行 <strong>3 維</strong>定位，所謂的 <strong>3 維</strong>，就是除了<strong>上下左右</strong>外，還有<strong>前後</strong>的概念。</p><h3 id="靜態定位（static）"><a href="#靜態定位（static）" class="headerlink" title="靜態定位（static）"></a>靜態定位（static）</h3><p>這是所有元素的預設值，一般的文檔流，對 <code>top</code> 、 <code>bottom</code> 、 <code>left</code> 、 <code>right</code> 、 <code>z-index</code> 沒有作用。<br><img src="https://i.imgur.com/lXxXkyK.png" alt="藍色框代表視窗，黑色框代表父容器。"></p><h3 id="相對定位（relative）"><a href="#相對定位（relative）" class="headerlink" title="相對定位（relative）"></a>相對定位（relative）</h3><p>相對定位，就是<strong>相對於原本自己位置</strong>的定位，因為是保持文檔流的狀態下移動自身位置，所以原本的位置還會<strong>保留空白</strong>，而移動的單位，可以是絕對單位（px），也可以是相對單位（%），相對單位會取<strong>父容器</strong>的大小當作參考值。<br><img src="https://i.imgur.com/h3MCaXE.png" alt="可以看出從左往右移動 100%，100% 取自父容器（黑框）的寬度做為參考值"></p><h3 id="絕對定位（absolute）"><a href="#絕對定位（absolute）" class="headerlink" title="絕對定位（absolute）"></a>絕對定位（absolute）</h3><p>絕對定位，會被移出文檔流，優先尋找擁有<strong>非靜態定位</strong>的祖先元素進行<strong>比對偏移</strong>，當祖先元素都沒有設置定位，則以根元素<code>&lt;body&gt;</code>作為參照對象偏移。此外在高度寬度沒寫死的情況下，寬度高度預設為 <code>auto</code> ，絕對定位會自動填滿上下左右設定值。<br><img src="https://i.imgur.com/Xy8K8mh.png" alt="可以看出當上下右都設 0 ，左設 50%，絕對定位會自動填滿視窗"></p><h3 id="固定定位（fixed）"><a href="#固定定位（fixed）" class="headerlink" title="固定定位（fixed）"></a>固定定位（fixed）</h3><p>固定定位，也是會被移出文檔流，而固定定位的參照對象是<strong>視窗</strong>，會固定在視窗畫面上，這時怎麼滾動畫面，他都會<strong>固定</strong>在那裡，與絕對定位一樣，寬度高度沒寫死的情況下，也會自訂根據上下左右設定值填滿。<br><img src="https://i.imgur.com/rPltrhz.gif" alt="可以看出固定在視窗下方"></p><h3 id="黏滯定位（sticky）"><a href="#黏滯定位（sticky）" class="headerlink" title="黏滯定位（sticky）"></a>黏滯定位（sticky）</h3><p>黏滯定位，不會移出文檔流，而是依據上下左右設定視窗界線，跟著滾動軸滾動到界線上後，黏住滯留在界線上。<strong>需注意</strong> 因為<strong>渲染順序</strong>的關係，下面元素會遮住上面的元素，右邊遮住左邊，所以通常定位元素都會設定<code>z-index</code>來安排誰前誰後，避免被下面的元素蓋過去。</p><p><img src="https://i.imgur.com/Cgj78sC.gif" alt="可以看出設定 top: 0，當元素接觸到視窗界線，而固定住，並利用 z-index 避免被下面的 static 元素遮住"></p><h3 id="又學會新的置中方法了？！"><a href="#又學會新的置中方法了？！" class="headerlink" title="又學會新的置中方法了？！"></a>又學會新的置中方法了？！</h3><p>統整一下前面學習的 margin 置中，與 Flexbox 置中，現在又多學會了利用定位元素來置中，只是定位元素的置中比較麻煩，還要使用後面要學的 transform 屬性來修正位置，所以只能說學會一半！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>到現在已經學會了最基礎的切版技能了，可以運用前面所學做出各式各樣的靜態頁面，下一章節要來介紹比較麻煩的<strong>偽元素 與 偽類選擇器</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.7 「CSS 網頁切版必學，用過都說讚！」 —— CSS 彈性盒模型 Flexbox</title>
    <link href="/2021/09/16/2021-9-16-it_ironman-day7/"/>
    <url>/2021/09/16/2021-9-16-it_ironman-day7/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-7-「CSS-網頁切版必學，用過都說讚！」-——-CSS-彈性盒模型-Flexbox"><a href="#Day-7-「CSS-網頁切版必學，用過都說讚！」-——-CSS-彈性盒模型-Flexbox" class="headerlink" title="Day.7 「CSS 網頁切版必學，用過都說讚！」 —— CSS 彈性盒模型 Flexbox"></a>Day.7 「CSS 網頁切版必學，用過都說讚！」 —— CSS 彈性盒模型 Flexbox</h1><p><img src="https://i.imgur.com/hLMVxvv.png" alt="「CSS 網頁切版必學，用過都說讚！」 —— CSS 彈性盒模型 Flexbox"></p><p>要來介紹大家最愛用的 Flexbox 了，以往兼容性還不太好的時候，大多都是使用表格（table）屬性來進行排版，也容易出問題，現在科技進步迅速，瀏覽器也持續跟進，<del>IE 也要進入歷史了</del>，只要用簡單的語法，就能安排元素在網頁上各自的位置，非常的方便好用又彈性！還不快學起來！</p><h2 id="為何稱為彈性盒？"><a href="#為何稱為彈性盒？" class="headerlink" title="為何稱為彈性盒？"></a>為何稱為彈性盒？</h2><p>Flexbox 之所以被稱之為彈性盒，是因為可以隨著視窗的尺寸，改變自己布局的方式，使用起來非常彈性，且易於使用，所以深受大家喜愛。<br><img src="https://i.imgur.com/ImmG3lU.gif" alt="隨著容器跟著伸縮"></p><h2 id="Flexbox-規則"><a href="#Flexbox-規則" class="headerlink" title="Flexbox 規則"></a>Flexbox 規則</h2><p>要了解 Flexbox ，就要先了解最基礎簡單的 Flexbox 父容器規則。<br><img src="https://i.imgur.com/73CcPV8.png" alt="Flexbox 規則"></p><p>當我們為<strong>父容器</strong>（藍框）添加 <code>display: flex;</code> 屬性後，其內部的子元件（灰色方形）將會以<strong>主軸</strong>（紅色箭頭），依序<strong>排列</strong>（紅色數字）與<strong>分布</strong>，並以<strong>交錯軸</strong>（綠色箭頭）讓子元件<strong>互相對齊基準線</strong>（方形上的綠色線）。</p><ul><li>由<strong>父容器</strong>設定 <code>display: flex;</code>，影響子元件布局</li><li>根據<strong>主軸</strong>方向安排子元件<strong>排列</strong>方向與分布</li><li>根據<strong>交錯軸</strong>設定<strong>對齊基準線</strong>。</li></ul><h2 id="父容器的設定"><a href="#父容器的設定" class="headerlink" title="父容器的設定"></a>父容器的設定</h2><h3 id="怎麼主導子元件排列方向（flex-direction）"><a href="#怎麼主導子元件排列方向（flex-direction）" class="headerlink" title="怎麼主導子元件排列方向（flex-direction）"></a>怎麼主導子元件排列方向（flex-direction）</h3><p>看完上面的規則後，我們發現有一個<strong>主軸</strong>負責控制排列方向與佈局。</p><ul><li><p><code>flex-direction</code>預設的值是<code>row</code>，指水平排列<br><img src="https://i.imgur.com/ZrzZq2K.png" alt="row"></p></li><li><p>當<code>flex-direction</code>值設<code>row-reverse</code>，指水平翻轉排列<br><img src="https://i.imgur.com/Pzm3WO5.png" alt="row-reverse"></p></li><li><p>當<code>flex-direction</code>值設<code>column</code>，指垂直排列</p></li><li><p>當<code>flex-direction</code>值設<code>column-reverse</code>，指垂直翻轉排列</p></li></ul><p><img src="https://i.imgur.com/ifPAjvP.png" alt="column &amp; column-reverse"></p><h3 id="控制主軸是否換行（flex-wrap）"><a href="#控制主軸是否換行（flex-wrap）" class="headerlink" title="控制主軸是否換行（flex-wrap）"></a>控制主軸是否換行（flex-wrap）</h3><p>Flexbox 彈性盒有個特性，當沒有特別設定要換行時，它預設是會想盡一切辦法把子元件都塞<strong>一行</strong>，如下圖，正方形因為彈性盒的緣故，被壓縮成長方形。</p><p><img src="https://i.imgur.com/Igogdcq.png" alt="nowrap"></p><p>當你設定<code>flex-wrap: wrap;</code>，塞不下的時候，它就會自動<strong>換行</strong>了<br><img src="https://i.imgur.com/Cf06taa.png" alt="wrap"></p><p>當你設定<code>flex-wrap: wrap-reverse</code>，除了會自動換行，而且是<strong>反向換行</strong>。<br><img src="https://i.imgur.com/oM9iITZ.png" alt="wrap-reverse"></p><h3 id="控制主軸的布局（justify-content）"><a href="#控制主軸的布局（justify-content）" class="headerlink" title="控制主軸的布局（justify-content）"></a>控制主軸的布局（justify-content）</h3><p>使用屬性<code>justify-content</code>，設定主軸布局</p><ul><li><code>flex-start</code>，預設是這個，往主軸起始點對齊</li><li><code>flex-end</code>，往主軸末端對齊</li><li><code>center</code>，往主軸中央對齊</li><li><code>space-between</code>，平均分配主軸位置，貼齊兩端</li><li><code>space-around</code>，平均分配主軸留白的部分（頭尾留白處相加會與中間留白處相等，就像跑馬燈元素間距離相等）</li></ul><p><img src="https://i.imgur.com/rT9lwvQ.png" alt="justify-content"></p><h3 id="控制一行，交錯軸的對齊（align-items）"><a href="#控制一行，交錯軸的對齊（align-items）" class="headerlink" title="控制一行，交錯軸的對齊（align-items）"></a>控制一行，交錯軸的對齊（align-items）</h3><p>使用屬性<code>align-items</code>，設定主軸布局</p><ul><li><code>flex-start</code>，預設是這個，往交錯軸起始點對齊</li><li><code>flex-end</code>，往交錯軸末端對齊</li><li><code>center</code>，往交錯軸中央對齊</li><li><code>baseline</code>，依照內容文本對齊</li><li><code>stretch</code>，在沒寫死子元件大小下，子元件自動撐滿交錯軸。</li></ul><p><img src="https://i.imgur.com/4cBX9XS.png" alt="align-items"><br><em>上圖數字代表行高倍率<code>line-height</code>，用來撐高以好展示效果</em></p><h3 id="控制多行，交錯軸的對齊（align-content）"><a href="#控制多行，交錯軸的對齊（align-content）" class="headerlink" title="控制多行，交錯軸的對齊（align-content）"></a>控制多行，交錯軸的對齊（align-content）</h3><p>當彈性盒子元件有換行時，才有作用，在單行時無作用！</p><ul><li><code>flex-start</code>，預設是這個，往交錯軸起始點開始排列</li><li><code>flex-end</code>，往交錯軸末端開始排列</li><li><code>center</code>，往交錯軸中央開始排列</li><li><code>space-between</code>，平均分配交錯軸位置，貼齊兩端</li><li><code>space-around</code>，平均分配交錯軸留白</li><li><code>stretch</code>，平均分配交錯籌位置</li></ul><p><img src="https://i.imgur.com/JRKnhSB.png" alt="align-content"></p><h2 id="子元素設定"><a href="#子元素設定" class="headerlink" title="子元素設定"></a>子元素設定</h2><p>已經了解 Flexbox 最常用的部分了，再來就是控制子元件的 flex，也是比較困難難懂精隨的部分，搞懂了，成功就離你不遠了！</p><h3 id="利用-flex-來自動幫你安排大小"><a href="#利用-flex-來自動幫你安排大小" class="headerlink" title="利用 flex 來自動幫你安排大小"></a>利用 flex 來自動幫你安排大小</h3><p>flex 總共又有劃分三個屬性</p><ul><li><p><code>flex-grow</code>，負責管理<strong>放大</strong>這個部分，預設是 0（不會放大），當有多個子元件設定時，數字代表比例<br><img src="https://i.imgur.com/OL9HOd2.gif" alt="flex-grow"></p></li><li><p><code>flex-shrink</code>，負責管理<strong>縮小</strong>這個部分，預設是 1 （隨父容器壓縮），設定為 0 時，則不會壓縮<br><img src="https://i.imgur.com/FPK0nG7.gif" alt="flex-shrink"></p></li></ul><ul><li><p><code>flex-basis</code>，負責管理<strong>基礎大小</strong>的部分，有壓縮，就會有設置<strong>基礎大小</strong>，避免被壓太小。</p></li><li><p><code>flex</code>的<strong>簡寫</strong>方式，<code>flex: &lt;grow&gt; &lt;shrink&gt; &lt;basis&gt;;</code>，當只有寫一個值時，那個值會代表 <code>grow 值</code></p></li></ul><h3 id="想來點不一樣的對齊方式？（align-self）"><a href="#想來點不一樣的對齊方式？（align-self）" class="headerlink" title="想來點不一樣的對齊方式？（align-self）"></a>想來點不一樣的對齊方式？（align-self）</h3><p>有時候想對<strong>子元件</strong>個別設定對齊方式，就可以個別對子元件設定<code>align-self</code>。</p><p>設定與<code>align-items</code>相似。</p><p><img src="https://i.imgur.com/GrhCydD.png" alt="align-self"></p><h3 id="我任性！就想自訂順序（order）"><a href="#我任性！就想自訂順序（order）" class="headerlink" title="我任性！就想自訂順序（order）"></a>我任性！就想自訂順序（order）</h3><p>用來設定<strong>順序</strong>*，預設為 0 ，數字越<strong>大</strong>越靠近<strong>主軸末端</strong>，反之越靠近<strong>起始點</strong>。<br><img src="https://i.imgur.com/jL4XZFa.png" alt="order"></p><h2 id="恭喜你！又多認識了一個垂直置中的好方法"><a href="#恭喜你！又多認識了一個垂直置中的好方法" class="headerlink" title="恭喜你！又多認識了一個垂直置中的好方法"></a>恭喜你！又多認識了一個垂直置中的好方法</h2><p>盒模型那一篇已經介紹了使用 <code>mragin: 0 auto;</code> 來把元素置中，現在又多認識了 Flexbox，恭喜你又多認識了一個把元素置中的好方法了，前面有介紹 DOM tree ，認識到<strong>文本</strong>也是單獨一個 DOM 節點，我們就可以利用 Flexbox 來達到<strong>水平垂直置中</strong>的效果了！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>當初在學 Flexbox，主要是透過 六角學院副校長——<strong>卡斯伯</strong>的 <a href="https://wcc723.github.io/css/2017/07/21/css-flex/">圖解：CSS flex屬性一點也不難</a> 學習的，讓我受益良多，另外也推薦兩款 Flexbox 小遊戲， <a href="https://flexboxfroggy.com/">Flexbox Froggy</a> 與 <a href="https://hexschool.github.io/flexbox-pirate/index.html#/">flex Pirate 海盜船</a>，對認識 Flexbox 效果滿好的，下一篇將進入我們的定位（Position）與浮動（float）章節</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.6 「只要我想，我也能把 div 變 table！」 —— CSS display 屬性</title>
    <link href="/2021/09/15/2021-9-15-it_ironman-day6/"/>
    <url>/2021/09/15/2021-9-15-it_ironman-day6/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-6-「只要我想，我也能把-div-變-table！」-——-CSS-display-屬性"><a href="#Day-6-「只要我想，我也能把-div-變-table！」-——-CSS-display-屬性" class="headerlink" title="Day.6 「只要我想，我也能把 div 變 table！」 —— CSS display 屬性"></a>Day.6 「只要我想，我也能把 div 變 table！」 —— CSS display 屬性</h1><p><img src="https://i.imgur.com/ofgbXuv.png" alt="「只要我想，我也能把 div 變 table！」 —— CSS display 屬性"></p><p>如同前面章節所說，一開始的標籤元素，很單調只有一行並沒有各式各樣的元素，是瀏覽器內建的樣式表賦予它該展示的樣子。</p><p><img src="https://i.imgur.com/A0uiSrM.png" alt="圖中，瀏覽器為 table 標籤賦予為 表格屬性"></p><p>所以我們可以把任何標籤變成任何你愛的樣子，當然不希望如此瞎搞！</p><p>能用標籤本身取代的冷門 display 屬性值暫且就不會介紹了，只介紹大家最常用的 display 屬性值。</p><h2 id="常用的-display-屬性值"><a href="#常用的-display-屬性值" class="headerlink" title="常用的 display 屬性值"></a>常用的 display 屬性值</h2><h3 id="inline-amp-block-行內元素-與-區塊元素"><a href="#inline-amp-block-行內元素-與-區塊元素" class="headerlink" title="inline &amp; block 行內元素 與 區塊元素"></a>inline &amp; block 行內元素 與 區塊元素</h3><p>這是大家最熟悉的屬性值了，相信不必我多說，你們也已經知道它的作用了</p><p><strong>值得</strong>注意的是，HTML 標籤換行，在渲染的時候會自動變成一個空白，如下圖<br><img src="https://i.imgur.com/mO39ScR.png" alt="最基礎的 區塊元素 與 行內元素"></p><h3 id="inline-block-行內區塊元素"><a href="#inline-block-行內區塊元素" class="headerlink" title="inline-block 行內區塊元素"></a>inline-block 行內區塊元素</h3><p>上上篇盒模型中，有發現 inline 元素的垂直方向都無法推擠，這時 inline-block 出現了<br><img src="https://i.imgur.com/TI35bGk.png" alt="同時具有 inline 並排的特性，還擁有 block 垂直推擠的特性。"><br>同時具有 inline 並排的特性，還擁有 block 垂直推擠的特性。</p><h3 id="none-隱藏"><a href="#none-隱藏" class="headerlink" title="none 隱藏"></a>none 隱藏</h3><p>none 屬性，也是很常使用的屬性，它的作用就是把元素整個隱藏消失，常見的範例就是，關掉廣告的這個動作。</p><p>與它非常相似的屬性還有一個，很常被提起討論的是<code>visibility: hidden;</code>這個屬性，與<code>display: none;</code>相似，但它只是單純的隱藏，高度位置還是在那裡<br><img src="https://i.imgur.com/oQbYhBT.png" alt="表面上隱藏，高度位置還是有占用"></p><h3 id="flex-彈性盒模型"><a href="#flex-彈性盒模型" class="headerlink" title="flex 彈性盒模型"></a>flex 彈性盒模型</h3><p><strong>彈性盒模型</strong>，目前最多人使用的屬性，方便易學的基礎排版，具有<strong>一維</strong>的概念，依靠父元素設定影響子元素<strong>一個方向</strong>的<strong>排列對齊</strong>。</p><p><img src="https://i.imgur.com/WcmxB4K.png" alt="依照主軸進行布局"><br><em>依照主軸進行布局</em></p><h3 id="grid-網格模型"><a href="#grid-網格模型" class="headerlink" title="grid 網格模型"></a>grid 網格模型</h3><p><strong>網格模型</strong>，近年來興起，許多瀏覽器開始慢慢支援，很多人想嘗試的屬性，與 flex 彈性盒模型有點像，不過是採取<strong>二維</strong>的概念，依靠父元素設定<strong>表格般</strong>影響子元素的布局。</p><p>現今也有很多 <strong>CSS 框架</strong>都有使用<strong>格線系統</strong>來進行排版，與網格模型個概念非常相近。</p><p><img src="https://i.imgur.com/X9VTWRV.png" alt="個平面上，隨意布局盒模型"><br><em>一個平面上，隨意布局盒模型。<a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/RwgjGWL">Codepen 範例</a></em></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>光是 flex 彈性盒模型就有很多細節可以講， grid 網格模型更是複雜，預計是不會講 grid 網格模型，如果有多餘時間再考慮補充，明天將介紹最受大家喜愛的 flex 彈性盒模型。</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.5 「我的樣式失靈啦！你有頭緒嗎？」 —— CSS 選擇器 與 權重</title>
    <link href="/2021/09/14/2021-9-14-it_ironman-day5/"/>
    <url>/2021/09/14/2021-9-14-it_ironman-day5/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-5-「我的樣式失靈啦！你有頭緒嗎？」-——-CSS-選擇器-與-權重"><a href="#Day-5-「我的樣式失靈啦！你有頭緒嗎？」-——-CSS-選擇器-與-權重" class="headerlink" title="Day.5 「我的樣式失靈啦！你有頭緒嗎？」 —— CSS 選擇器 與 權重"></a>Day.5 「我的樣式失靈啦！你有頭緒嗎？」 —— CSS 選擇器 與 權重</h1><p><img src="https://i.imgur.com/DGvbCcT.png" alt="「我的樣式失靈啦！你有頭緒嗎？」 —— CSS 選擇器 與 權重"></p><p>了解盒模型後，就要為標籤套上各種花樣了，上一篇介紹了簡單的套用方法，但這個套用方法其實不太好用！</p><p>使用標籤元素套用就像是畫草圖上底色，雖然有色彩但不細緻，這時為了能夠更精雕細琢我們的網頁，於是我們要更加精準的設定樣式，但有的選擇器必須謹慎使用，不然後面要修改就麻煩了。</p><!-- more --><h2 id="CSS-的使用方式"><a href="#CSS-的使用方式" class="headerlink" title="CSS 的使用方式"></a>CSS 的使用方式</h2><ul><li>在標籤內寫 <code>style</code> 屬性，稱為 inline style</li><li>在 <code>&lt;head&gt;</code> 標籤內添加 <code>&lt;style&gt;</code>，稱為 HTML style</li><li>還有一個上一篇沒介紹的外部載入樣式，是用外部連結 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;樣式網址&quot;&gt;</code> 標籤，同樣是放在  <code>&lt;head&gt;</code> 內，稱為 link style。</li></ul><h3 id="這三個有什麼差異與影響？"><a href="#這三個有什麼差異與影響？" class="headerlink" title="這三個有什麼差異與影響？"></a>這三個有什麼差異與影響？</h3><ul><li><strong>維護</strong>上，inline style 和 HTML style 都是寫在 HTML 這個檔案內的，HTML 會越來越大，比較不好維護。</li><li><strong>載入有順序性</strong>，上面樣式屬性會被下面<strong>同個</strong>屬性取代，所以 inline style &gt; HTML style &gt; link style。</li><li>inline style 通常會保留給 <strong>Javascript</strong> 做網站互動。</li></ul><h3 id="如何撰寫-link-style？"><a href="#如何撰寫-link-style？" class="headerlink" title="如何撰寫 link style？"></a>如何撰寫 link style？</h3><p><img src="https://i.imgur.com/DExuoCr.png" alt="link CSS"></p><ul><li>新增 <code>.css</code> 副檔名的檔案，並透過<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./樣式.css&quot;&gt;</code>就可以引入了<br><strong>注意</strong> 引入自己的檔案要使用<strong>相對路徑</strong>來引入</li><li>接著就可以在 CSS 檔寫樣式，與在 <code>&lt;style&gt;</code> 內寫法相同（不需要寫<code>&lt;style&gt;</code>標籤）</li><li>除了引入自己的檔案，也可以引入網路上的 CSS 檔案。</li></ul><h2 id="CSS-選擇器"><a href="#CSS-選擇器" class="headerlink" title="CSS 選擇器"></a>CSS 選擇器</h2><p>這裡要先補充，選擇器鎖定的元素不一定只有一個，可以藉由<strong>組合</strong>，來選擇其後代的所有元素。<br>但會建議選擇器階層<strong>別超過三層</strong>，因為瀏覽器會一層一層比對，當超過三層瀏覽器的渲染<strong>效率</strong>會下降許多。<br>把握簡單原則，當要超過三層時，就可以考慮再新增一個<strong>選擇器</strong></p><p><img src="https://i.imgur.com/qtv6Rqd.png" alt="CSS effective"><br><em>如圖如果都是要指定 menu 下的 <code>&lt;a&gt;</code>標籤，下面這樣指定也能達到同樣效果</em></p><h3 id="element-元素選擇器"><a href="#element-元素選擇器" class="headerlink" title="element 元素選擇器"></a>element 元素選擇器</h3><p>首先先介紹我們最<strong>基礎</strong>最簡單直白的元素選擇器，階級分數為 1 分，<br>用來畫草圖的選擇器。</p><p><img src="https://i.imgur.com/l0nfufP.png" alt="elements select"><br><em>如圖利用<code>&lt;header&gt;</code>&amp;<code>&lt;main&gt;</code>，來區分兩個區域的<code>&lt;h2&gt;</code>，另外<code>&lt;body&gt;</code>也是標籤可以設定</em></p><h3 id="class-類別選擇器"><a href="#class-類別選擇器" class="headerlink" title="class 類別選擇器"></a>class 類別選擇器</h3><p>最受歡迎的 class 選擇器，<br>比起有限的標籤選擇器，能夠<strong>自由命名</strong>的 class 選擇器更方便，階級分數為 10 分，<br>可以用來構圖，也能細琢的，屬於最好用方便的選擇器。</p><p><img src="https://i.imgur.com/dg0wJCR.png" alt="class select"><br><em>如圖利用 class 命名成顏色直接套用</em></p><p>需在標籤屬性添加 <code>class=&quot;red&quot;</code> 屬性，透過使用 <code>.red&#123; 樣式 &#125;</code> 來套用樣式</p><h3 id="id-選擇器"><a href="#id-選擇器" class="headerlink" title="id 選擇器"></a>id 選擇器</h3><p>id 這個屬性有個特性，就是一個 HTML 檔案中，每個 id 都要<strong>獨一無二</strong>的。<br>所以相較受歡迎的 class 選擇器，id 選擇器也就比較難被使用。階級分數為 100 分。<br>因為它的<strong>獨特性</strong>，且階級分數高，所以在使用上綁手綁腳的，比較<strong>不推薦</strong>在 CSS 中使用 id 選擇器。</p><p><img src="https://i.imgur.com/wmalwua.png" alt="id select"><br><em>如圖顯示 id 選擇器階級分數高，蓋過 class 選擇器樣式</em></p><p>如果要使用，標籤屬性要添加 <code>id=&quot;red&quot;</code> 屬性，透過使用 <code>#red&#123; 樣式 &#125;</code> 來套用樣式</p><h3 id="運算符號選擇器"><a href="#運算符號選擇器" class="headerlink" title="運算符號選擇器"></a>運算符號選擇器</h3><p>有時候會希望選擇器能更靈活的使用，像上一篇的<code>box-sizing: border-box;</code>，如果要一個一個標籤都要使用，還不累死，這時就可以使用運算符號選擇器，運算符號選擇器有個特點，就是本身沒有權重。</p><ul><li><p><code>*</code> 選擇器，可以把全部的標籤都套用的選擇器，如：<code>* &#123; box-sizing: border-box; &#125;</code>。</p></li><li><p><code>&gt;</code> 選擇器，可以把子代元素套用樣式，不影響孫代元素。常用在階層列表中。</p><blockquote><p>何謂子代、孫代？<br>如同我們的祖譜，父元素下一層就是子元素，在下一層就是孫元素，此時子元素就是孫元素的父元素，好像有點饒舌。</p></blockquote><p><img src="https://i.imgur.com/Vw0QhBT.png" alt="child select"><br><em>透過 <code>&gt;</code> 選擇器，只改變第一層顏色</em></p></li><li><p><code>+</code> 選擇器，可以把選擇器同層級第一個遇到的元素套用樣式。常用來修正列表邊框。<br><img src="https://i.imgur.com/7tV99kY.png" alt="fix list border"><br><em>透過 <code>+</code> 選擇器，搭配上一篇所學的 margin 負值來修正邊框。</em></p></li><li><p><code>~</code> 選擇器，跟 <code>+</code> 選擇器很像，只是這次不是選取第一個，而是選取全部符合條件的。</p></li><li><p>還有其他選擇器，放在後面的篇章在講</p></li></ul><h2 id="CSS-權重"><a href="#CSS-權重" class="headerlink" title="CSS 權重"></a>CSS 權重</h2><p>上面已經稍微認識權重了，權重大的會蓋過權重小的。<br><strong>注意</strong> 雖然用分數來比擬權重，但其實就算使用 11 個 class 選擇器，也蓋不過 1 個 id 選擇器。</p><ul><li>元素選擇器，權重是 1</li><li>類別選擇器，權重是 10</li><li>ID 選擇器，權重是 100</li><li><code>*</code> 選擇器，權重是 0</li><li>前面說的 inline style，權重高達 1000</li><li>!important ，權重最高 <strong>10000</strong></li></ul><h3 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h3><p>沒錯～!important，就是多麼無敵的存在，連 inline style 都無法保住自己絕對的地位。<br>所以在使用 !important 時，務必想清楚，最好是別隨便的亂使用</p><p><img src="https://i.imgur.com/VXJX0b3.png" alt="!important"><br><em>透過使用 !important 強制蓋過樣式。</em></p><p>使用方法為，在你需要把權重調最高的樣式後添加 <code>!important;</code>。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這邊了解如何使用選擇器，與權重的概念了，也了解到 HTML 中 <code>id</code> 、 <code>class</code> 與 <code>style</code> 這三個屬性，還有幾個很重要的觀念沒說，像是<strong>命名的藝術</strong>、命名的<strong>邏輯</strong>、樣式的<strong>複用性</strong>也都是很重要的，礙於篇幅有限，未來有機會再提起，還有一些 CSS 的樣式這系列應該不會說那麼細，<strong>推薦</strong>可以去看 CSScoke 金魚系列的文章，下一篇我們將介紹 CSS 的 display 屬性。</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>CSS</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.4 「CSS 基礎中的基礎！」 —— CSS 盒模型 box-model &amp; 距離單位</title>
    <link href="/2021/09/13/2021-9-13-it_ironman-day4/"/>
    <url>/2021/09/13/2021-9-13-it_ironman-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-4-「CSS-基礎中的基礎！」-——-CSS-盒模型-box-model-amp-距離單位"><a href="#Day-4-「CSS-基礎中的基礎！」-——-CSS-盒模型-box-model-amp-距離單位" class="headerlink" title="Day.4 「CSS 基礎中的基礎！」 —— CSS 盒模型 box-model &amp; 距離單位"></a>Day.4 「CSS 基礎中的基礎！」 —— CSS 盒模型 box-model &amp; 距離單位</h1><p><img src="https://i.imgur.com/v6IIogk.png" alt="「CSS 基礎中的基礎！」 —— CSS 盒模型 box-model &amp; 距離單位"></p><h2 id="人是視覺動物"><a href="#人是視覺動物" class="headerlink" title="人是視覺動物"></a>人是視覺動物</h2><p>當網頁架構用得差不多了，想自己安排布局，會開始想辦法把網頁變得更漂亮。<br>Google Chrome 很好用，有提供開發者工具給我們除錯，點開 elements 標籤最下面會有個方形的圖案。</p><p><img src="https://i.imgur.com/JVqvJ0K.png" alt="盒模型 box-model"></p><p>這就是我們今天的主角 —— <strong>CSS</strong> 的基礎<strong>盒模型 box-model</strong></p><!-- more --><h2 id="什麼是-CSS？"><a href="#什麼是-CSS？" class="headerlink" title="什麼是 CSS？"></a>什麼是 CSS？</h2><p>CSS 是 Cascading Style Sheets 的簡寫，中文翻譯為階層式樣式表。<br>名字內有階層兩個字，顧名思義，他可以使用多個選擇器組合，來達到階層式的管理樣式。</p><h3 id="如何使用-CSS？"><a href="#如何使用-CSS？" class="headerlink" title="如何使用 CSS？"></a>如何使用 CSS？</h3><p>先教兩個最<strong>簡單</strong>最<strong>基本</strong>的 CSS 使用方法。<br><img src="https://i.imgur.com/mvfQaQr.png" alt="最簡單的 CSS 使用方法"></p><ul><li><p>在 <code>&lt;head&gt;</code> 標籤內添加 <code>&lt;style&gt;</code> 標籤，如<strong>紅色框</strong>，標籤內使用你要套用 CSS 樣式的標籤名，如<strong>橘色框</strong>，在裡面撰寫屬性值，如<strong>紅色框內的橘色框</strong>。</p></li><li><p>或著直接在標籤內添加 <code>style</code> 屬性，並在裡面賦予屬性值，如<strong>綠色框</strong>。</p></li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型能幫助我們更加了解如何操控網頁並進行排版。<br>每個標籤都有獨立的盒模型，看盒模型我們可以觀察到有三個英文單字，四個顏色</p><ul><li>紅色：<code>margin</code>，外邊距，可以想成與下一個標籤的距離</li><li>橘色：<code>border</code>，邊框，就是內容的外框</li><li>綠色：<code>padding</code>，內邊距，可以想成內容與外框的留白距離</li><li>藍色：內容</li></ul><h3 id="距離單位"><a href="#距離單位" class="headerlink" title="距離單位"></a>距離單位</h3><p>在學習盒模型語法時，必須先了解 CSS 的距離單位。</p><h4 id="不管在哪都固定大小的單位"><a href="#不管在哪都固定大小的單位" class="headerlink" title="不管在哪都固定大小的單位"></a>不管在哪都固定大小的單位</h4><ul><li>px 是絕對單位，為螢幕中最基礎單位，1px 代表 1 個點，如下圖：字的大小 24px，固定在視窗內佔 24 位元的大小</li><li>rem 是相對單位，每個<strong>元素</strong>都依據<strong>根元素</strong>的 px 值乘以<strong>倍數</strong>，如下圖：字的大小 1.5rem，固定比祖先大 1.5 倍的大小，瀏覽器內建字體原始大小為 16px。</li></ul><h4 id="取決於父元素單位大小的單位"><a href="#取決於父元素單位大小的單位" class="headerlink" title="取決於父元素單位大小的單位"></a>取決於父元素單位大小的單位</h4><ul><li>em 是相對單位，每個<strong>子元素</strong>都依據<strong>父元素</strong>的 px 值乘以<strong>倍數</strong>，如下圖：字的大小 1.5em，比老爸大 1.5 倍。</li><li>% 是相對單位，每個<strong>子元素</strong>都依據<strong>父元素</strong>的 px 值乘以<strong>百分比</strong>，如下圖：字的大小 150%，比老爸大 150 %。</li></ul><h4 id="取決於視窗大小的單位"><a href="#取決於視窗大小的單位" class="headerlink" title="取決於視窗大小的單位"></a>取決於視窗大小的單位</h4><ul><li>vh 是相對單位，每個<strong>元素</strong>都依據<strong>視窗</strong>的（像素高度 / 100）乘以倍數，如下圖：字的大小 5vh，視窗的 1 / 20 <strong>高</strong>的大小。</li><li>vw 是相對單位，每個<strong>元素</strong>都依據<strong>視窗</strong>的（像素寬度 / 100）乘以倍數，如下圖：字的大小 5vw，視窗的 1 / 20 <strong>寬</strong>的大小。</li></ul><p><img src="https://i.imgur.com/YqTwWv1.png" alt="圖片為各種單位的示意圖"></p><h3 id="盒模型通用語法"><a href="#盒模型通用語法" class="headerlink" title="盒模型通用語法"></a>盒模型通用語法</h3><p>可以看到盒模型在<code>margin</code>、<code>border</code>、<code>padding</code>，都可以在四個方位設定距離</p><p>而設定的語法也很簡單直白，在此用<code>margin</code>做示範：</p><ul><li><code>margin-top: 上距</code>，上外邊距</li><li><code>margin-right: 右距</code>，右外邊距</li><li><code>margin-bottom: 下距</code>，下外邊距</li><li><code>margin-left: 左距</code>，左外邊距</li></ul><h4 id="一行程式碼簡化的語法"><a href="#一行程式碼簡化的語法" class="headerlink" title="一行程式碼簡化的語法"></a>一行程式碼簡化的語法</h4><ul><li><code>margin: 上距 右距 下距 左距</code>，四個值的順序不能錯，分別設定<strong>上</strong>、<strong>右</strong>、<strong>下</strong>、<strong>左</strong></li><li><code>margin: 上距 水平距 下距</code>，三個值的順序不能錯，分別設定<strong>上</strong>、<strong>左右</strong>、<strong>下</strong></li><li><code>margin: 垂直距 水平距</code>，兩個值的順序不能錯，分別設定<strong>上下</strong> 與 <strong>左右</strong></li><li><code>margin: 距離</code>，一個值你也很難錯，<strong>四個方向一起設定</strong></li></ul><blockquote><p>以上 margin 也可以提替成 border 來設定 border 或 padding 來設定 padding</p></blockquote><h3 id="Margin-的特色"><a href="#Margin-的特色" class="headerlink" title="Margin 的特色"></a>Margin 的特色</h3><p>因為 Margin 毛最多，所以先來說 Margin，搞定 Margin，後面就輕鬆了！</p><p>上下相隔的距離<strong>會重疊</strong>。<br><img src="https://i.imgur.com/ChVScKT.png" alt="上下相隔的距離會重疊"></p><p>左右相隔的距離<strong>不會重疊</strong>。<br><img src="https://i.imgur.com/6MCayhD.png" alt="左右相隔的距離不會重疊"></p><p><strong>行內元素</strong>的垂直 margin 沒有效果。<br><img src="https://i.imgur.com/JzyzpcK.png" alt="行內元素的垂直 margin 沒有效果"></p><p>可以使用<strong>負值</strong>，讓元素重疊，<strong>注意</strong> 在同個層級，右邊會壓過左邊，下面會壓過上面<br><img src="https://i.imgur.com/EKKPqUc.png" alt="margin 負值，同層級下，右邊蓋住左邊"></p><h4 id="父子元素-Margin-外邊距重疊"><a href="#父子元素-Margin-外邊距重疊" class="headerlink" title="父子元素 Margin 外邊距重疊"></a>父子元素 Margin 外邊距重疊</h4><p>當<strong>父元素</strong>包著<strong>子元素</strong>，同時都有使用 margin 時，<strong>垂直</strong> margin 會取<strong>最大</strong>的 margin 值<br>![垂直 margin 會重疊]](<a href="https://i.imgur.com/quUpAkb.png">https://i.imgur.com/quUpAkb.png</a>)</p><p>但當父元素有設定 padding 或 border 時，就不會重疊了。<br><img src="https://i.imgur.com/CYsrCCn.png" alt="設定 padding 或 border ，margin 就不會重疊了"></p><p>還有屬於<strong>不同</strong>的 BFC 元素，如：子元素使用 float 浮動元素</p><blockquote><p>什麼是 BFC？ BFC 是 Block formatting context 簡寫，簡單的說就是定位的方式改變。想更瞭解可以看<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">MDN 官方文件</a></p></blockquote><p>這個部分要等到認識更多 CSS 才比較好解釋。<br>簡單說，就是脫離老爸的控制（脫離文檔流）</p><blockquote><p>什麼是脫離文檔流？ 簡單說，原本每個元素都是一個個盒模型，依次排列在網頁上面，看起來像流水般由上而下依序排下來，稱之為「文檔流」。而脫離文檔流，顧名思義就是脫離出來的意思。</p></blockquote><h3 id="Border-的特色"><a href="#Border-的特色" class="headerlink" title="Border 的特色"></a>Border 的特色</h3><p>可以設定邊框的<strong>寬度</strong>、<strong>樣式</strong>與<strong>顏色</strong><br>此外還可以使用 border-radius 來設定<strong>外圍</strong>的圓滑程度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: 寬度 樣式 顏色;<br><span class="hljs-attribute">border-radius</span>: 圓滑程度;<br></code></pre></td></tr></table></figure><p>寬度、樣式、顏色上網查，比較容易理解易學，就不多加琢磨了。</p><p>稍微介紹圓滑程度<code>border-radius</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 這個是沒有字母的最基本型態 */</span><br><span class="hljs-selector-class">.border</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid <span class="hljs-number">#f88</span>; &#125;<br><span class="hljs-comment">/* 當設定一個值，四個角都會依據設定值為半徑做弧度 */</span><br><span class="hljs-selector-class">.a</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>; &#125;<br><span class="hljs-comment">/* 當設定為 % 數，會依照內容寬度乘以百分比為半徑做弧度 */</span><br><span class="hljs-selector-class">.b</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>; &#125; <br><span class="hljs-comment">/* 當有兩個值，第一個值對應的是左上與右下，第二個值對應的是右上與左下 */</span><br><span class="hljs-selector-class">.c</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">50%</span>; &#125;<br><span class="hljs-comment">/* 當有三個值，第一個值對應左上，第二個值對應的是右上與左下，第三個值為右下 */</span><br><span class="hljs-selector-class">.d</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">100%</span> <span class="hljs-number">50%</span>; &#125;<br><span class="hljs-comment">/* 當有四個值，就順時針從右上開始分別對應值 */</span><br><span class="hljs-selector-class">.e</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">25%</span> <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>; &#125;<br><span class="hljs-comment">/* 當要做特別形狀時，參數會更麻煩 */</span><br><span class="hljs-selector-class">.f</span> &#123; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">30%</span> <span class="hljs-number">70%</span> <span class="hljs-number">70%</span> <span class="hljs-number">30%</span> / <span class="hljs-number">30%</span> <span class="hljs-number">30%</span> <span class="hljs-number">70%</span> <span class="hljs-number">70%</span>; &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ElanoDL.png" alt="上面的英文字母分別對應形狀"></p><p><a href="https://9elements.github.io/fancy-border-radius/">想做特別的圓弧形？</a></p><h3 id="Padding-的特色"><a href="#Padding-的特色" class="headerlink" title="Padding 的特色"></a>Padding 的特色</h3><p>Padding 就相對單純許多。<br>可以設定內容留白的寬度，與 margin 語法差不多，顏色則取自內容的背景色，背景顏色也是很簡單易學的語法，可以上網查，更進階的漸層背景顏色、多重背景、濾鏡背景，如果未來有時間會補充。<br>在行內元素狀態下，padding 水平會正常，但垂直就跟 margin 一樣會失效。如圖：<br><img src="https://i.imgur.com/C7tugxA.png" alt="行內元素 垂直 padding 失效"><br>此外值得一提的是，margin 是元素之間的距離，所以不能算在元素內，padding 則是在元素內留白的距離，算是元素的一份子，常見的例子就是按鈕。</p><h2 id="想要把元素推到中間置中？"><a href="#想要把元素推到中間置中？" class="headerlink" title="想要把元素推到中間置中？"></a>想要把元素推到中間置中？</h2><h3 id="盒模型還有-auto-這個值"><a href="#盒模型還有-auto-這個值" class="headerlink" title="盒模型還有 auto 這個值"></a>盒模型還有 auto 這個值</h3><p>除了寫數字值外，我們也可以請瀏覽器幫忙我們計算</p><ul><li>auto 是讓瀏覽器決定自動調整的距離單位，通常用在<strong>水平置中</strong>或<strong>自動推移</strong></li></ul><p><img src="https://i.imgur.com/WQmkumP.png" alt="添加 auto 的作用"></p><h2 id="怎麼設定的大小跟我想像的不一樣？"><a href="#怎麼設定的大小跟我想像的不一樣？" class="headerlink" title="怎麼設定的大小跟我想像的不一樣？"></a>怎麼設定的大小跟我想像的不一樣？</h2><p>這裡要介紹一個現在很多人都會使用的盒模型語法<code>box-sizing: border-box</code></p><p>以往的網頁切版充滿了數學計算，<br>因為 border 與 padding 要另外計算，如下圖<code>content-box</code>，<br>寬度總共 <code>border</code>10×2+<code>padding</code>10×2+<code>width</code>100 = 140px<br>想要把總寬度變 100px 就要往回扣 <code>width</code>。</p><p>但把 CSS 全域設成 <code>box-sizing: border-box;</code>，<br>就可以設定寬度 100px ，瀏覽器會幫我們計算，<br>可以更<strong>直覺性</strong>的設定內容的寬高！<br><img src="https://i.imgur.com/qarkIjK.png" alt="content-box 與 border-box 的差異"></p><p>至於 <code>width</code> 和 <code>height</code> 基礎語法，這個語法也很簡單，主要難是在判斷對的時機使用，這要多做才知道哪些情況要使用。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒想到如此基礎的 盒模型，也有很多重要觀念，明天將介紹 CSS 如何更精準的套用樣式。</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>HTML</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.3 「建構網頁的基石！」 —— 使用網頁標籤</title>
    <link href="/2021/09/12/2021-9-12-it_ironman-day3/"/>
    <url>/2021/09/12/2021-9-12-it_ironman-day3/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-3-「建構網頁的基石！」-——-使用網頁標籤"><a href="#Day-3-「建構網頁的基石！」-——-使用網頁標籤" class="headerlink" title="Day.3 「建構網頁的基石！」 —— 使用網頁標籤"></a>Day.3 「建構網頁的基石！」 —— 使用網頁標籤</h1><p><img src="https://i.imgur.com/3myJcyZ.png" alt="「建構網頁的基石！」 —— 使用網頁標籤"></p><p>我們前面已經稍微認識了網頁的架構了，就像樂高一塊一塊堆疊起來，前一篇已經介紹的就不多贅述了。</p><p>雖然會最基礎的<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>標籤就能夠開始切版了，甚至只靠<code>&lt;div&gt;</code>搭配 CSS 就能做出各種 tag 的效果，但為了良好的 SEO 與 <strong>閱讀性</strong>，也為了以後不會把別人<del>自己</del>逼瘋 (?，還是會建議用更適合的標籤來完成網頁。</p><!-- more --><blockquote><p>什麼是 SEO？ 是 Search Engine Optimization 的縮寫，中文翻譯為搜尋引擎最佳化。<br>簡單解釋就是，好的 SEO 等於讓搜尋引擎在茫茫網路大海中，讓你更容易被搜尋到。</p></blockquote><p>根據 80/20 法則，其實學會 2 成的標籤，就已經能好好建構出不錯的網頁了，一些不常用的標籤，倒也不用硬是死記，需要用時再 Google 就好 (<del>也許根本用不到</del>。</p><h2 id="常用的標籤"><a href="#常用的標籤" class="headerlink" title="常用的標籤"></a>常用的標籤</h2><h3 id="用來表示地盤的標籤"><a href="#用來表示地盤的標籤" class="headerlink" title="用來表示地盤的標籤"></a>用來表示地盤的標籤</h3><p>這種標籤最主要是用來劃分區域的標籤，通常會有子元素。</p><ul><li><p><code>&lt;div&gt;</code> 沒有語意的標籤，也是最常使用的標籤</p></li><li><p><code>&lt;header&gt;</code> 代表容器的頭部</p></li><li><p><code>&lt;main&gt;</code> 代表容器主要內容</p></li><li><p><code>&lt;footer&gt;</code> 代表容器的底部</p></li><li><p><code>&lt;section&gt;</code> 代表一個段落</p></li><li><p><code>&lt;nav&gt;</code> 代表導航列</p></li></ul><p><img src="https://i.imgur.com/HesZUPB.png" alt="iT ironman"><br><em>如圖紅色框使用的是 <code>&lt;nav&gt;</code>，黃色使用的是 <code>&lt;header&gt;</code></em></p><p><strong>注意</strong> 這邊是用容器，代表<code>&lt;header&gt;</code>不一定要放在整個網頁的最上面<br>也可以用<code>&lt;main&gt;</code>包住，代表主要內容的頭部。</p><h3 id="給文字（text）使用的標籤"><a href="#給文字（text）使用的標籤" class="headerlink" title="給文字（text）使用的標籤"></a>給文字（text）使用的標籤</h3><ul><li><p><code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code> 內文的標題，數字 1 代表第一重要標題，依序往下推，最小標題為<code>&lt;h6&gt;</code>，會<strong>影響 SEO</strong>，一個網頁建議只要有<strong>一個</strong><code>&lt;h1&gt;</code>標籤</p></li><li><p><code>&lt;p&gt;</code> &amp; <code>&lt;pre&gt;</code> 內文區塊標籤，<code>&lt;pre&gt;</code>會保留格式，<code>&lt;p&gt;</code>則不會</p></li><li><p><code>&lt;span&gt;</code> 同樣沒有語意，主要是要在區塊元素內套用不同 CSS 的標記標籤</p></li><li><p><code>&lt;a&gt;</code> 能夠超連結外部網站（href=”網址”）、進行錨點傳送（href=”#id_name”）、進行網路電話（href=”tel:電話號碼”）或電子信箱（href=”mailto:電子信箱”）<br><strong>注意</strong> <code>&lt;a&gt;</code>標籤內不能再嵌套<code>&lt;a&gt;</code>標籤。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com.tw/&quot;</span>&gt;</span>Google 超連結<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>進行錨點傳送至頂<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;tel:+886-987654321&quot;</span>&gt;</span>進行網路電話<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:email@gmail.com&quot;</span>&gt;</span>寄信給電子信箱<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><a href="https://www.google.com.tw/">Google 超連結</a><br><a href="#">進行錨點傳送至頂</a><br><a href="tel:+886-987654321">進行網路電話</a><br><a href="mailto:email@gmail.com">寄信給電子信箱</a></p><h3 id="關於圖片（image）的標籤"><a href="#關於圖片（image）的標籤" class="headerlink" title="關於圖片（image）的標籤"></a>關於圖片（image）的標籤</h3><ul><li><p><code>&lt;img&gt;</code> 圖片標籤 <code>src=&quot;圖片網址&quot; alt=&quot;圖片說明文字&quot;</code>。<br><strong>注意</strong> <code>alt</code> 必須填寫，當圖片檔失效，會顯示說明文字，此外還會提供給視障人士聽到圖片說明。</p></li><li><p><code>&lt;figure&gt;</code> 這也算佔領地盤的標籤，代表放圖片的<strong>區域</strong>，子元素可以多個<code>&lt;img&gt;</code></p></li><li><p><code>&lt;figcaption&gt;</code> 代表圖片區域的文字介紹，可以讓瀏覽器知道這段文字與這個圖片區域有關聯。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.imgur.com/THgsIlG.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>Hello image<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://i.imgur.com/THgsIlG.jpg" alt="hello"><br>Hello image</p><h3 id="好用的列表（list）標籤"><a href="#好用的列表（list）標籤" class="headerlink" title="好用的列表（list）標籤"></a>好用的列表（list）標籤</h3><ul><li><p><code>&lt;ul&gt;</code> 用來設定<strong>無序</strong>列表</p></li><li><p><code>&lt;ol&gt;</code> 用來設定<strong>有序</strong>列表</p></li><li><p><code>&lt;li&gt;</code> 需與<code>&lt;ul&gt;</code>或<code>&lt;ol&gt;</code>搭配，用來設定列表項目</p></li></ul><p><strong>常見</strong> 的使用時機，像導航條那樣，同一個內容排列的時候就很適合使用！<br><img src="https://i.imgur.com/ll8OSOq.png" alt="導航條"><br><em>如圖綠色框為 <code>&lt;ul&gt;</code>，紅色框為 <code>&lt;li&gt;</code></em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是無序列表 代號蘋果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是無序列表 代號橘子<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是有序列表 代號小辣椒<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是有序列表 代號老薑<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>我是無序列表 代號蘋果</li><li>我是無序列表 代號橘子</li></ul><ol><li>我是有序列表 代號小辣椒</li><li>我是有序列表 代號老薑</li></ol><h3 id="製作表格用的表格（table）標籤"><a href="#製作表格用的表格（table）標籤" class="headerlink" title="製作表格用的表格（table）標籤"></a>製作表格用的表格（table）標籤</h3><ul><li><p><code>&lt;table&gt;</code> 用來設定表格</p></li><li><p><code>&lt;tr&gt;</code> 用來設定一列（row）</p></li><li><p><code>&lt;th&gt;</code> 需與<code>&lt;tr&gt;</code>搭配，表示表格標題（column）</p></li><li><p><code>&lt;td&gt;</code> 需與<code>&lt;tr&gt;</code>搭配，表示表格內容（column）</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>我是表格標題 報數 第一班 班頭<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>我是表格標題 報數 第二班 班頭<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>我是表格標題 報數 第三班 班頭<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>我是表格內容 報數 第一班 2 號<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>我是表格內容 報數 第二班 2 號<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>我是表格內容 報數 第三班 2 號<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>我是表格標題 報數 第一班 班頭</th><th>我是表格標題 報數 第二班 班頭</th><th>我是表格標題 報數 第三班 班頭</th></tr></thead><tbody><tr><td>我是表格內容 報數 第一班 2 號</td><td>我是表格內容 報數 第二班 2 號</td><td>我是表格內容 報數 第三班 2 號</td></tr></tbody></table><h3 id="必學的表單（form）標籤"><a href="#必學的表單（form）標籤" class="headerlink" title="必學的表單（form）標籤"></a>必學的表單（form）標籤</h3><ul><li><p><code>&lt;form&gt;</code> 想要把資料傳給後端，就需要依靠<code>&lt;form&gt;</code>標籤</p></li><li><p><code>&lt;label&gt;</code> 表單說明標籤，這個是配合<code>&lt;input&gt;</code>標籤，利用屬性<code>for=&quot;id_name&quot;</code>鎖定<code>&lt;input id=&quot;id_name&quot;&gt;</code></p></li><li><p><code>&lt;input&gt;</code> 單行輸入標籤，這個標籤本身自閉合，本身<code>type</code>有很多屬性值。</p><ul><li><code>type = &quot;text&quot;</code>，輸入文字</li><li><code>type = &quot;password&quot;</code>，輸入的文字會屏蔽</li><li><code>type = &quot;email&quot;</code>，輸入信箱，會自動驗證格式是否正確</li><li><code>type = &quot;number&quot;</code>，只能輸入數字</li><li><code>type = &quot;radio&quot;</code>，只能單選，要添加<code>name</code>屬性，來判斷範圍</li><li><code>type = &quot;checkbox&quot;</code>，可以複選，要添加<code>name</code>屬性，來判斷範圍</li><li><code>type = &quot;button&quot;</code>，就普通的按鈕</li><li><code>type = &quot;submit&quot;</code>，能發送表單的按鈕</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>名字<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>請選擇性別<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>請選擇你擁有的技能<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;html&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skill&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skill&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;css&quot;</span>&gt;</span>css<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skill&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>Javascript<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/iijkuTY.png" alt="form - input"></p><ul><li><p><code>&lt;textarea&gt;</code>，多行輸入標籤，需要閉合標籤，需要使用<code>row</code>和<code>col</code>屬性，來決定大小</p></li><li><p><code>&lt;select&gt;</code>，下拉式選單</p></li><li><p><code>&lt;option&gt;</code>，下拉式選單的選項</p></li><li><p><code>&lt;optgroup&gt;</code>，下拉式選單的預設顯示</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>請選擇疫苗<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>AZ 疫苗<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>莫德納疫苗<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>高端疫苗<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2a8naoL.png" alt="form - select"></p><h3 id="進階的嵌入用標籤"><a href="#進階的嵌入用標籤" class="headerlink" title="進階的嵌入用標籤"></a>進階的嵌入用標籤</h3><ul><li><code>&lt;ifram&gt;</code> 用來內嵌網頁，如：Google 地圖、Code pen</li><li><code>&lt;video&gt;</code> 用來內嵌影片檔</li><li><code>&lt;audio&gt;</code> 用來內嵌音樂檔</li><li><code>&lt;canvas&gt;</code> 用來實現繪圖、遊戲具互動性的標籤</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然 HTML 很簡單，但標籤真的又臭又多，這只是冰山一角，還有很多屬性沒介紹，但前期這樣也很夠用了，下一篇將進入我們的 CSS 篇章！</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>HTML</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.2 「歡迎來到網頁這個世界！」 —— 認識網頁架構</title>
    <link href="/2021/09/11/2021-9-11-it_ironman-day2/"/>
    <url>/2021/09/11/2021-9-11-it_ironman-day2/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-2-「歡迎來到網頁這個世界！」-——-認識網頁架構"><a href="#Day-2-「歡迎來到網頁這個世界！」-——-認識網頁架構" class="headerlink" title="Day.2 「歡迎來到網頁這個世界！」 —— 認識網頁架構"></a>Day.2 「歡迎來到網頁這個世界！」 —— 認識網頁架構</h1><p><img src="https://i.imgur.com/xadMCtM.png" alt="「歡迎來到網頁這個世界！」 —— 認識網頁架構"></p><h2 id="網頁世界是由什麼組成？"><a href="#網頁世界是由什麼組成？" class="headerlink" title="網頁世界是由什麼組成？"></a>網頁世界是由什麼組成？</h2><p>上一篇有講到網頁三兄弟，其中有一個老大哥負責撐起這個世界，那就是 HTML ，少了 HTML 這個根基，就不會有網頁。<br>只有 HTML 的世界是非常無聊的，這時 CSS 和 Javascript 接連出現，為網頁世界創造更多的可能！</p><!-- more --><ul><li>HTML 負責撐起網頁</li><li>CSS 負責為網頁增添色彩</li><li>Javascript 負責為網頁增加互動性</li></ul><h2 id="認識-HTML"><a href="#認識-HTML" class="headerlink" title="認識 HTML"></a>認識 HTML</h2><h3 id="HTML-是什麼？"><a href="#HTML-是什麼？" class="headerlink" title="HTML 是什麼？"></a>HTML 是什麼？</h3><p>HTML 是 Hyper Text Markup Language 的縮寫，中文翻譯為<strong>超文本標示語言</strong>，是樣板語言。</p><blockquote><p>什麼是樣板語言？ 主要給樣板處理器（瀏覽器）產生畫面的語言</p></blockquote><h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><p>HTML 的世界是由上往下建構的，最後會變成一個 DOM tree 樹狀圖。</p><blockquote><p>什麼是 DOM？　DOM 是 Document Object Model 的縮寫，中文翻譯為<strong>文件物件模型</strong></p></blockquote><p><img src="https://i.imgur.com/pkhQ83z.png" alt="HTML"><br>轉換成 樹狀圖架構<br><img src="https://i.imgur.com/zWx3NJn.png" alt="DOM tree"></p><ul><li>紅色框是 HTML5 的檔案聲明，用來告訴瀏覽器這個文件是什麼類型。</li><li>橙色框是最根部的標籤，用來標記網頁所使用的語言，如：<code>en</code> 為英文，<code>zh-TW</code> 為繁體中文。</li><li>黃色框是要給瀏覽器看的設定，不會顯示在網頁上。<ul><li><code>&lt;meta&gt;</code>是給瀏覽器看的設定值，如：字元編碼、RWD、網頁 icon 、網頁描述…等。</li><li><code>&lt;title&gt;</code>是給網頁的標題。</li><li><code>&lt;link&gt;</code>是用來引入 CSS 的。</li><li><code>&lt;script&gt;</code>用來引入 Javascript 使用的，但大多數人會設在網頁尾端，之後再講為什麼。</li></ul></li><li>綠色框是網頁的主要內容呈現。</li><li>藍色框是標籤的屬性。</li><li>樹狀圖具有上下關係，如：<code>&lt;body&gt;</code>子元素為<code>&lt;h1&gt;</code>、<code>&lt;h1&gt;</code>父元素為<code>&lt;body&gt;</code>。</li><li>父元素可以有多個子元素，子元素只有一個父元素。</li></ul><h3 id="標籤"><a href="#標籤" class="headerlink" title="標籤"></a>標籤</h3><p><img src="https://i.imgur.com/AS6R8dd.png" alt="h1 tag"></p><ul><li>深藍色字是標籤名稱</li><li>淺藍色字是屬性名稱</li><li>橘色字是屬性值</li><li>白色字是文本</li><li>大多數標籤都要使用結束標籤做結尾，如：<code>&lt;/h1&gt;</code></li></ul><h2 id="HTML-是怎麼呈現的？"><a href="#HTML-是怎麼呈現的？" class="headerlink" title="HTML 是怎麼呈現的？"></a>HTML 是怎麼呈現的？</h2><p>最原始的 HTML 是沒有所謂的區塊元素，而是各家的瀏覽器自己設定預設的樣式，讓 HTML 更加容易閱讀。</p><p><img src="https://i.imgur.com/PnXC70n.png" alt="h1 tag"><br><em>如圖 <code>&lt;h1&gt;</code> Google Chrome 內建樣式</em></p><p>雖然各家瀏覽器的樣式都不太一樣，但整體大方向還是一樣的，都有區分出區塊元素與行內元素。<br>多數情況下，會用區塊元素劃分位置，行內元素會放在區塊元素內。</p><ul><li>區塊元素（block）：在沒有使用 CSS ，會包覆著子元素蓋一整行，如：<code>div</code>、<code>h1</code>、<code>ul</code>…等。</li><li>行內元素（inline）：可以多個行內並排，直到排不下就會往下推擠，如：<code>span</code>、<code>img</code>、<code>input</code>…等。</li></ul><iframe height="300" style="width: 100%;" scrolling="no" title="HTML - block &amp; inline" src="https://codepen.io/vsfvjiuv-the-typescripter/embed/PojpZzZ?default-tab=html%2Cresult&editable=true" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/PojpZzZ">  HTML - block &amp; inline</a> by Johnson Mao (<a href="https://codepen.io/vsfvjiuv-the-typescripter">@vsfvjiuv-the-typescripter</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe>*為了更好的呈現效果，所以有稍微添加一些 CSS*<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>現在已經初步認識網頁的架構了，明天將會深入了解各個標籤的用法與注意事項。<br>如果想自己做出樹狀圖，可以玩玩看，只是架構有點麻煩。</p><iframe height="300" style="width: 100%;" scrolling="no" title="DOM tree" src="https://codepen.io/vsfvjiuv-the-typescripter/embed/PojpLeg?default-tab=html%2Cresult&editable=true" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/vsfvjiuv-the-typescripter/pen/PojpLeg">  DOM tree</a> by Johnson Mao (<a href="https://codepen.io/vsfvjiuv-the-typescripter">@vsfvjiuv-the-typescripter</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>HTML</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day.1 「工欲善其事，必先利其器！」—— 前言 與 介紹工具</title>
    <link href="/2021/09/10/2021-9-10-it_ironman-day1/"/>
    <url>/2021/09/10/2021-9-10-it_ironman-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-1-「工欲善其事，必先利其器！」——-前言-與-介紹工具"><a href="#Day-1-「工欲善其事，必先利其器！」——-前言-與-介紹工具" class="headerlink" title="Day.1 「工欲善其事，必先利其器！」—— 前言 與 介紹工具"></a>Day.1 「工欲善其事，必先利其器！」—— 前言 與 介紹工具</h1><p><img src="https://i.imgur.com/YyhvZBl.png" alt="「工欲善其事，必先利其器！」—— 前言 與 介紹工具"></p><h2 id="大家好"><a href="#大家好" class="headerlink" title="大家好"></a>大家好</h2><p>我是毛毛，因為這波疫情影響下，讓我多了許多時間可以好好投資自己，想把自己目前所學的技能，轉化成能夠讓更多人更好吸收的知識，如果有發現內容有誤，也請您不吝指教，感謝。</p><!-- more --><h2 id="這個系列"><a href="#這個系列" class="headerlink" title="這個系列"></a>這個系列</h2><p>關於這個系列，會盡量著重在使用簡單好懂的解說，介紹網頁三兄弟（ HTML 、 CSS 、 Javascript ）所需要的知識，會嘗試把過程中所學到的東西，製作出一個小網站，希望在編寫的同時，回顧自己是否確實搞懂，正所謂最好的學習方式除了輸入，還要懂得輸出。</p><h2 id="使用的編輯器"><a href="#使用的編輯器" class="headerlink" title="使用的編輯器"></a>使用的編輯器</h2><p>我會推薦使用 VS Code 編輯器，因為他非常適合開發 HTML 、 CSS 、 Javascript，而且套件、社群也已經相當成熟了，對於新手來說，非常容易入門。<br><a href="https://code.visualstudio.com/download">VS Code 下載官網</a></p><h3 id="善用套件，事半功倍"><a href="#善用套件，事半功倍" class="headerlink" title="善用套件，事半功倍"></a>善用套件，事半功倍</h3><p>VS Code 有相當多個套件可以使用，這裡先介紹常用的套件，當然還有許多套件值得你慢慢尋找。</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant">Chinese (Traditional) Language Pack for Visual Studio Code</a><br>  習慣看中文介面？ 這個套件可以把 VS Code 轉成繁體中文版。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow">indent-rainbow</a><br>  縮排不知縮到哪去？ 幫縮排添加顏色，讓程式碼更加容易閱讀。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">Bracket Pair Colorizer</a><br>  在寫 Javascript 漏打一個括弧而找得很辛苦？ 這個套件幫你把對應的括弧上相同顏色。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server</a><br>  開發網站想看網站的呈現？ 這個套件可以幫你及時更新畫面，不用一直按 F5。</p></li></ul><h3 id="善用快捷鍵，時間就是金錢"><a href="#善用快捷鍵，時間就是金錢" class="headerlink" title="善用快捷鍵，時間就是金錢"></a>善用快捷鍵，時間就是金錢</h3><p>將雙手盡量停留在鍵盤上，能更有效提升寫 code 的效率，這裡先介紹我常用的快捷鍵。<br>此篇以 Windows 操作，如果是 Mac 可能會有些許不一樣<br>Mac 需把 <code>Ctrl</code> 換成 <code>Cmd ⌘</code></p><ul><li><p>VS Code 非常貼心，本身就內建 HTML 、 CSS 、Javascript 的 Emmet，只要輸入縮寫語法，按下 Tab 或 Enter 就能擴充縮寫來快速編寫。需注意縮寫語法取決於副檔名。<br><img src="https://i.imgur.com/Vi5ZXGn.gif" alt="縮寫語法"><br><em>此圖範例為，新增檔案切換成 HTML 副檔名，並使用 HTML emmet</em></p></li><li><p><code>Ctrl</code> + <code>D</code> 可以同字串選取。<br><img src="https://i.imgur.com/zWquMNw.gif" alt="同字串選取"><br><em>此圖範例為，選取 MyNavLink 換成 NavLink</em></p></li><li><p>還在整段<code>Ctrl</code> + <code>C</code> + <code>Ctrl</code> + <code>V</code>，複製程式碼嗎？可以嘗試看看使用一個<code>Shift</code> + <code>Alt</code> + <code>上或下</code>來複製程式碼<br><img src="https://i.imgur.com/Li08fjb.gif" alt="Shift + Alt + 上或下來複製程式碼"><br><em>此圖範例為，把整個<code>&lt;ul&gt;</code>格式複製貼上</em></p></li><li><p>使用<code>Shift</code> + <code>Alt</code> + <code>F</code>，就能快速為程式碼進行 Format 排版<br><img src="https://i.imgur.com/lJDcUXS.gif" alt="快速為程式碼進行 Format 排版"><br><em>此圖範例為，使用<code>Shift</code> + <code>Alt</code> + <code>F</code>進行快速排版</em></p></li><li><p>別再左側資料夾慢慢找檔案，善用<code>Ctrl</code> + <code>E</code>或<code>Ctrl</code> + <code>P</code>搜尋檔案，就可以直接切換檔案<br><img src="https://i.imgur.com/jHQoBOG.gif" alt="Ctrl + P 搜尋檔案，就可以直接切換檔案"><br><em>此圖範例為，快速導覽至 Nav.jsx</em></p></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這是我個人常用的套件工具與快捷鍵，準備好我們的工具，接下來就要進入我們的網頁篇～<br>也歡迎大家在下面留言補充更多好玩好用的套件～</p>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>工具</category>
      
      <category>VS Code</category>
      
      <category>iT 鐵人賽</category>
      
      <category>第 2021 年</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iT 鐵人賽</tag>
      
      <tag>VS Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2021/09/06/2021-9-6-mongodb/"/>
    <url>/2021/09/06/2021-9-6-mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p><img src="https://i.imgur.com/E7ajmZa.jpg" alt="資料庫概念圖"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在製作自己的專案時，想讓專案更加完整，於是就開始想，既然前端畫面邏輯都自己開發了，現在網路上資源又那麼豐富，未來也有可能朝全端發展，何不自己架設後端 API，給自己串接，還能了解整個網頁的運作邏輯，於是開始自學了後端框架 Express 和資料庫 MongoDB，這裡將會記錄學習 MongoDB 的學習筆記。</p><!-- more --><h2 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h2><h3 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h3><ul><li>關聯式資料庫（RDBMS）<ul><li>資料具有關聯性</li><li>表格化、標準化</li><li>如：MySQL</li></ul></li><li>非關聯式資料庫（Not only SQL）<ul><li>更加彈性化（不一定要使用 SQL）</li><li>如：MongoDB</li></ul></li><li>SQL 是什麼？<ul><li>SQL 是<strong>結構化查詢語言</strong></li><li>所有的關聯式資料庫都是用 SQL</li><li>會 SQL 就大致上能快速學會關聯式資料庫（每個資料庫還是有些微的不同）</li></ul></li></ul><h3 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li>是快速開發 Web 而設計的資料庫</li><li>極簡、靈活性高</li><li>存取的是各式各樣的 BSON。</li><li>BSON 就是二進制的 JSON。</li><li>MongodDB 架構 可以有多個資料庫<ul><li>database 為資料庫，存放多個集合<ul><li>collection 集合，存放多個文件<ul><li>document 文件，我們操作的部分</li></ul></li></ul></li></ul></li></ul><h2 id="MongoDB-安裝-與-啟動"><a href="#MongoDB-安裝-與-啟動" class="headerlink" title="MongoDB 安裝 與 啟動"></a>MongoDB 安裝 與 啟動</h2><h3 id="安裝-MongoDB"><a href="#安裝-MongoDB" class="headerlink" title="安裝 MongoDB"></a>安裝 MongoDB</h3><p>可以去官網依自己的作業系統下載。<br>建議安裝版本為偶數結尾（穩定版）。<br><a href="https://docs.mongodb.com/manual/administration/install-community/">官網下載網站</a></p><p>==注意==：安裝建議用使用預設的比較不容易出錯，自訂的話，路徑不能有中文。</p><h3 id="設置環境變數"><a href="#設置環境變數" class="headerlink" title="設置環境變數"></a>設置環境變數</h3><p>我這裡是安裝 Windows 的 MongoDB 5.0 版本</p><ol><li><p>找到安裝 MongoDB 的資料夾，直到找到裡面的 bin 資料夾<br> 範例：<code>C:\Program Files\MongoDB\Server\5.0\bin</code></p></li><li><p>開啟電腦的環境變數，對使用者變數裡面的 PATH 編輯，並把剛剛 bin 的路徑新增到 PATH 內（需注意不要動到裡面其他的路徑）<br> 以我 Windows 10 為例：<br> 打開我的電腦 &gt; 開啟設定 &gt; 開啟進階系統設定 &gt; 系統內容進階 tag 內點環境變數 &gt; 對 PATH 進行編輯</p></li><li><p>在 C:\ 根目錄新增 data 資料夾，裡面新增 db 資料夾。</p></li><li><p>開啟 CMD 輸入 <code>Mongod</code> 啟動服務器後縮小</p></li><li><p>再開啟另一個 CMD 輸入 <code>Mongo</code> 連接資料庫，連接成功 CMD 會出現 <code>&gt;</code></p></li></ol><h3 id="開機自動啟動服務器"><a href="#開機自動啟動服務器" class="headerlink" title="開機自動啟動服務器"></a>開機自動啟動服務器</h3><ol><li><p>在 MongoDB 版本那個資料夾新增<code>mongod.cfg</code>檔案<br> 如：<code>C:\Program Files\MongoDB\Server\5.0</code>新增<code>mongod.cfg</code></p></li><li><p>在<code>mongod.cfg</code>內輸入設定</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cfg">systemLog:<br>    destination: file<br>    path: c:\data\log\mongod.log   # 這裡輸入 log 檔案<br>storage:<br>    dbPath: c:\data\db   # 這裡輸入資料要存的位置<br>net:<br>    port: 27017   # 這裡輸入想要的 port 號<br></code></pre></td></tr></table></figure></li><li><p>開啟系統管理員身分的 CMD 在 <strong>bin 資料夾</strong> 輸入 <code>mongod.exe --config</code></p></li><li><p>在 <strong>資料存取位置</strong> 輸入 <code>god.cfg --install</code></p></li><li><p>接著輸入 <code>net start MongoDB</code> 啟動服務器</p></li></ol><h2 id="圖形化工具安裝"><a href="#圖形化工具安裝" class="headerlink" title="圖形化工具安裝"></a>圖形化工具安裝</h2><p>除了使用 CMD 來操作 MongoDB 外，也有圖形化工具可以使用<br><a href="https://www.mongodbmanager.com/download">下載圖形化工具網站</a></p><h2 id="操作資料庫"><a href="#操作資料庫" class="headerlink" title="操作資料庫"></a>操作資料庫</h2><p>使用 <code>use &lt;database&gt;</code> 新增並進入資料庫<br>如：<code>use test</code></p><p>當你新增資料時，<code>&lt;collection&gt;</code>為你的集合名。<br>如：<code>db.students.insert(&#123; name: &quot;毛毛&quot;, gender: &quot;男&quot;&#125;)</code><br>這時資料庫就會自動新增 students 這個集合，<br>這個集合裡面有個<code>&#123; name: &quot;毛毛&quot;, gender: &quot;男&quot;&#125;</code>的資料，<br>輸入<code>show collection</code> 就可以看到 students<br>輸入<code>show dbs</code>就可以看到資料庫名稱 test</p><p>想刪除集合，只要輸入<code>db.students.drop()</code>就會刪除集合。<br>想刪除當前所在的資料庫，只要輸入<code>db.dropDatabase()</code></p><h3 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h3><p><code>db.&lt;collection&gt;.insert(資料)</code><br>可以新增 JSON 資料，一個資料傳物件，多個資料傳陣列。<br>新增後如果沒有自訂<code>_id</code>值的話，MongoDB 會自動生成 <code>_id</code>，確保每個資料都是唯一性。</p><p><code>db.&lt;collection&gt;.insertOne()</code> 只能傳一個物件。<br><code>db.&lt;collection&gt;.insertMany()</code> 只能傳一個陣列。</p><h3 id="查詢資料"><a href="#查詢資料" class="headerlink" title="查詢資料"></a>查詢資料</h3><p><code>db.&lt;collection&gt;.find(條件)</code><br>可以傳物件，當作查詢集合的參考，返回陣列。<br>如：傳<code>&#123;&#125;</code>就會顯示所有資料</p><p><code>db.&lt;collection&gt;.findOne()</code> 返回第一個查到的物件。<br><code>db.&lt;collection&gt;.find().count()</code> 返回查詢的數量。（length()一樣）</p><h4 id="如果想加入條件"><a href="#如果想加入條件" class="headerlink" title="如果想加入條件"></a><strong>如果想加入條件</strong></h4><p>假設想查詢 price &gt; 100 的資料，條件加上 <code>$gt</code><br>範例：<code>db.&lt;collection&gt;.find(&#123;price: &#123;$gt: 100&#125; &#125;)</code><br>假設想查詢 price &gt;= 100 的資料，條件加上 <code>$gte</code><br>範例：<code>db.&lt;collection&gt;.find(&#123;price: &#123;$gte: 100&#125; &#125;)</code><br>假設想查詢 price &lt; 100 的資料，條件加上 <code>$lt</code><br>範例：<code>db.&lt;collection&gt;.find(&#123;price: &#123;$lt: 100&#125; &#125;)</code><br>假設想查詢 90 &lt; price &lt; 100 的資料，條件之間加上<code>,</code><br>範例：<code>db.&lt;collection&gt;.find(&#123;price: &#123;$lt: 100, $gt: 90&#125; &#125;)</code><br>假設想查詢前 10 筆資料，使用 <code>limit(數量)</code><br>範例：<code>db.&lt;collection&gt;.find().limit(10)</code><br>假設想查詢第 11 ~ 20 筆資料，使用 <code>limit(數量)</code>外，還要使用<code>skip(跳過幾筆)</code><br>範例：<code>db.&lt;collection&gt;.find().skip(10).limit(10)</code></p><h3 id="更新資料"><a href="#更新資料" class="headerlink" title="更新資料"></a>更新資料</h3><p><code>db.&lt;collection&gt;.update(查詢條件, 更新資料)</code><br>透過第一個參數查詢到第一筆資料，第二個參數默認情況下會直接取代原有資料。</p><h4 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h4><p><code>db.&lt;collection&gt;.update(查詢條件, &#123; $set: &#123;更新資料&#125; &#125;)</code><br>第二個參數增加 $set 修改操作符，就可以合併資料，而不是取代。</p><p><code>db.&lt;collection&gt;.update(查詢條件, &#123; $unset: &#123;刪除資料&#125; &#125;)</code><br>第二個參數改成 $unset 修改操作符，就可以把資料指定屬性刪除。</p><h4 id="修改多筆資料"><a href="#修改多筆資料" class="headerlink" title="修改多筆資料"></a>修改多筆資料</h4><p><code>db.&lt;collection&gt;.updateMany()</code><br>update 默認情況只會修改一個資料，可以使用 updateMany 同時修改多筆資料。</p><p><code>db.&lt;collection&gt;.update(查詢條件, &#123; $set: &#123;更新資料&#125; &#125;, &#123; multi: true &#125;)</code><br>透過傳入第三個參數<code>&#123; multi: true &#125;</code>，也可以同時修改多筆資料。</p><h4 id="修改的資料是多層陣列或多層物件"><a href="#修改的資料是多層陣列或多層物件" class="headerlink" title="修改的資料是多層陣列或多層物件"></a>修改的資料是多層陣列或多層物件</h4><p>如果資料裡面是陣列或物件，<br>想修改裡面的屬性就要把操作符換成 $push 或 $addToSet 新增 或 $pop 移除，<br>查詢條件支持用<code>.</code>搜尋，但要用<strong>引號</strong>包起來。</p><p>$push 與 $addToSet 的差別在於</p><ul><li>$push 會直接添加。</li><li>$addToSet 如果資料內有一樣的資料不會添加，沒有則會添加。</li></ul><h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><p><code>db.&lt;collection&gt;.remove(查詢條件)</code><br><code>db.&lt;collection&gt;.deleteMany(查詢條件)</code><br>刪除符合條件的多筆資料</p><p><code>db.&lt;collection&gt;.remove(查詢條件, true)</code><br><code>db.&lt;collection&gt;.deleteOne(查詢條件)</code><br>刪除符合條件的第一筆資料</p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://ithelp.ithome.com.tw/articles/10186324">Day17 - MongoDB 安裝設定</a></li><li><a href="https://www.youtube.com/watch?v=Q9r8guQo58k&list=PLmOn9nNkQxJGX-finJqCSVVZx3gwn4Rga">MongoDB 入門教學影片</a></li><li><a href="https://docs.mongodb.com/manual/">MongoDB MANUAL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>資料庫</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 三大屬性 Props</title>
    <link href="/2021/07/31/2021-7-31-react-props/"/>
    <url>/2021/07/31/2021-7-31-react-props/</url>
    
    <content type="html"><![CDATA[<h1 id="React-三大屬性-Props"><a href="#React-三大屬性-Props" class="headerlink" title="React - 三大屬性 Props"></a>React - 三大屬性 <strong>Props</strong></h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹組件 三大屬性中的 Props 屬性。</p><!-- more --><h2 id="React-起手式"><a href="#React-起手式" class="headerlink" title="React 起手式"></a>React 起手式</h2><ol><li><p>老規矩，先建立一個 HTML，並搭建好環境</p><p> <a href="/2021/07/26/2021-7-26-react-base/#React-%E8%B5%B7%E6%89%8B%E5%BC%8F">還不知道 HTML 起手式請點我</a></p></li></ol><h2 id="Props-基礎"><a href="#Props-基礎" class="headerlink" title="Props - 基礎"></a>Props - 基礎</h2><ol><li><p>在 script 中，使用類式組件。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：小傑·富力士<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：男<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>念能力：強化系<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>這樣就先完成了最簡單的組件<br><img src="https://i.imgur.com/4FMKZSR.png" alt="組件"></p></li><li><p>接著開始運用<code>props</code>功能</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123; this.props.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年齡：&#123; this.props.age &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：&#123; this.props.gender &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在 Person 標籤內添加 props 屬性</span><br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;小傑·富力士&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>接著開啟 live server，就可以查看到<code>props</code>內傳遞的值<br><img src="https://i.imgur.com/CwE0VGj.png" alt="Props 值"></p></li><li><p>再利用解構賦值，簡化程式碼</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 這樣每次使用都可以不用加 this.props 了</span><br>        <span class="hljs-keyword">const</span> &#123; name, age, gender &#125; = <span class="hljs-built_in">this</span>.props;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123; name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年齡：&#123; age &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：&#123; gender &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在 Person 標籤內添加 props 屬性</span><br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;小傑·富力士&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li></ol><h2 id="Props-批量傳遞-amp-運算"><a href="#Props-批量傳遞-amp-運算" class="headerlink" title="Props 批量傳遞 &amp; 運算"></a>Props 批量傳遞 &amp; 運算</h2><ol><li><p>當資料要代入許多<code>props</code>時，可以用 React 裡提供的方法，來批量傳遞</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; name, age, gender &#125; = <span class="hljs-built_in">this</span>.props;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123; name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年齡：&#123; age &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：&#123; gender &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 資料</span><br><span class="hljs-keyword">const</span> hunter = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小傑·富力士&quot;</span>, <br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;12&quot;</span>, <br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>, <br>&#125;<br><span class="hljs-comment">// 運用 React 裡提供的方法，類似 ES6 的展開運算符&#x27;...&#x27;，來批量傳遞</span><br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...hunter</span>&#125;/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>當小傑使用強制成長，把年齡提升 10 歲則可以直接在<code>&#123;&#125;</code>內進行運算</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; name, age, gender &#125; = <span class="hljs-built_in">this</span>.props;<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123; name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年齡：&#123; age + 10 &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：&#123; gender &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 資料</span><br><span class="hljs-keyword">const</span> hunter = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小傑·富力士&quot;</span>, <br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;12&quot;</span>, <br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>, <br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...hunter</span>&#125;/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>看到畫面時，這時候聰明的你，一定知道問題出在哪裡<br><img src="https://i.imgur.com/xlDYm6H.png" alt="型別問題"></p></li><li><p>沒錯！把資料的字串型態改成數字型態就能正常運算了。<br> <strong>當多人協作，且專案龐大時，很容易不小心出錯，變成難以找到問題</strong></p></li></ol><h3 id="檢查-props-資料型態與預處理的套件"><a href="#檢查-props-資料型態與預處理的套件" class="headerlink" title="檢查 props 資料型態與預處理的套件"></a>檢查 props 資料型態與預處理的<strong>套件</strong></h3><ol><li><p>有些時候資料不齊全時，可以設置一些警告，來避免找不到問題出在哪裡<br> 例如：資料沒有名字，性別亂寫，年齡是字串型態。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 資料</span><br><span class="hljs-keyword">const</span> hunter = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;12&quot;</span>, <br>    <span class="hljs-attr">gender</span>: <span class="hljs-number">9453</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://i.imgur.com/vCsSlla.png" alt="錯誤呈現"></p></li><li><p>可以再環境配置裡新引入 <a href="https://cdnjs.com/libraries/prop-types">prop-types CDN</a></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.7.2/prop-types.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>為組件裡面，<code>render</code>上面，新增資料型態檢查</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 需注意這裡 propTypes 的 p 是小寫，React 設定的</span><br><span class="hljs-keyword">static</span> propTypes = &#123;<br>    <span class="hljs-comment">// 這裡 PropTypes 的 P 是大寫，套件設定的</span><br>    <span class="hljs-attr">name</span>: PropTypes.string,<br>    <span class="hljs-attr">age</span>: PropTypes.number,<br>    <span class="hljs-attr">gender</span>: PropTypes.string,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>這時雖然畫面還是一樣，但開發人員工具就會出現警告<br> 馬上就能發現資料型態的錯誤<br><img src="https://i.imgur.com/fe8LdL1.png" alt="警告"></p></li><li><p>這時發現沒名字卻沒報錯，在必須傳遞的資料添加<code>.isRequired</code>，就會設定必須傳，否則報錯</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> propTypes = &#123;<br>    <span class="hljs-comment">// 設定 isRequired 為必傳</span><br>    <span class="hljs-attr">name</span>: PropTypes.string.isRequired,<br>    <span class="hljs-attr">age</span>: PropTypes.number,<br>    <span class="hljs-attr">gender</span>: PropTypes.string,<br>    <span class="hljs-comment">// 如果要限定傳函數則設 PropTypes.func</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/SZ4jnbd.png" alt="警告"></p><ol start="6"><li><p>這時名字年齡修正好，而性別故意不寫的話，為不是必傳的值，新增默認值</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 新增默認值，如果沒有設年齡的預設值，資料沒年齡時，會變成 NaN</span><br><span class="hljs-keyword">static</span> defaultProps = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;無&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://i.imgur.com/FnionQe.png" alt="成功畫面"></p></li></ol><h2 id="使用函數式組件來進行-props-傳遞"><a href="#使用函數式組件來進行-props-傳遞" class="headerlink" title="使用函數式組件來進行 props 傳遞"></a>使用函數式組件來進行 props 傳遞</h2><ul><li><p>雖然函數式組件沒有 this 指向，但可以透過參數來進行 props 傳遞</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"> props </span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> &#123; name, age, gender &#125; = props;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123; name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年齡：&#123; age &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性別：&#123; gender &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-comment">// 資料</span><br><span class="hljs-keyword">const</span> hunter = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小傑·富力士&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span><br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...hunter</span>&#125;/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;app&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li></ul><h2 id="總結-Props"><a href="#總結-Props" class="headerlink" title="總結 Props"></a>總結 Props</h2><ol><li>props 是透過組件的<strong>標籤屬性</strong>傳遞。</li><li>PropTypes 套件非必須，但有使用除錯會比較快。<ul><li>需注意使用時的<strong>大小寫</strong>，大小寫寫錯雖然不會報錯，但會失效。</li></ul></li><li>props 是從組件<strong>外</strong>往組件<strong>內</strong>傳遞資料</li><li><strong>注意</strong> props 只能<strong>讀取</strong>，不可修改。</li><li>React 中 props 可以透過<code>...</code>展開運算符展開屬性</li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/components-and-props.html">React 官網 - Components &amp; Props</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 三大屬性 State</title>
    <link href="/2021/07/29/2021-7-29-react-state/"/>
    <url>/2021/07/29/2021-7-29-react-state/</url>
    
    <content type="html"><![CDATA[<h1 id="React-三大屬性-State"><a href="#React-三大屬性-State" class="headerlink" title="React - 三大屬性 State"></a>React - 三大屬性 <strong>State</strong></h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹組件 三大屬性中的 State 屬性，這裡還不會討論 Hook 運用。</p><!-- more --><h2 id="React-起手式"><a href="#React-起手式" class="headerlink" title="React 起手式"></a>React 起手式</h2><ol><li><p>老規矩，先建立一個 HTML，並搭建好環境</p><p> <a href="/2021/07/26/2021-7-26-react-base/#React-%E8%B5%B7%E6%89%8B%E5%BC%8F">還不知道 HTML 起手式請點我</a></p></li></ol><h2 id="創建組件，完成基礎頁面"><a href="#創建組件，完成基礎頁面" class="headerlink" title="創建組件，完成基礎頁面"></a>創建組件，完成基礎頁面</h2><ol><li><p>在 script 中，要引用 React 的三大屬性，若不考慮使用 Hook ，則需使用類式組件。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你打疫苗了嗎? 還沒QQ<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>畫面呈現</p><p> <img src="https://i.imgur.com/y2nKsGB.png" alt="你打疫苗了嗎? 還沒QQ"></p></li></ol><h2 id="創建建構子，初始化狀態"><a href="#創建建構子，初始化狀態" class="headerlink" title="創建建構子，初始化狀態"></a>創建建構子，初始化狀態</h2><ol><li><p>在類式組件內添加建構子</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-comment">// 建構子，寫 props 傳遞參數</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-comment">// 建構子內要寫 super 接收 props，不然會報錯</span><br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-comment">// 初始化狀態，官方規定要寫物件型式</span><br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 這裡把回答變成 JS 表達式 &#123;&#125;，並使用用條件運算子</span><br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你打疫苗了嗎? </span><br><span class="xml">            &#123; this.state.vaccinated ? &#x27; 已經打了(．▽．) b&#x27; : &#x27; 還沒(Q A Q)&#x27; &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>因為我們把<code>vaccinated:</code>設為<code>true</code>，所以條件運算子就會選<code>:</code>前面的字串。</p><p> <img src="https://i.imgur.com/Mn3nvCs.png" alt="true 畫面"></p></li><li><p>如果我們把<code>vaccinated:</code>改成<code>false</code>，那麼條件運算子就會選擇<code>:</code>後面的字串。</p><p> <img src="https://i.imgur.com/y2nKsGB.png" alt="false 畫面"></p></li><li><p>這時打開開發者工具的 Component，可以看到<code>state</code>。</p><p> <img src="https://i.imgur.com/tLQV8Op.png" alt="State 狀態"></p></li><li><p>最後再更進階一點，把代碼更加精簡，將<code>render</code>內提取狀態進行<strong>解構賦值</strong>，讓程式更容易閱讀。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 在這裡先進行解構賦值，讀取狀態</span><br>    <span class="hljs-keyword">const</span> &#123; vaccinated &#125; = <span class="hljs-built_in">this</span>.state<br>    <span class="hljs-comment">// 這樣後面就可以直接利用變數，不用再加前墜</span><br>    <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你打疫苗了嗎? </span><br><span class="xml">        &#123; vaccinated ? &#x27; 已經打了(．▽．) b&#x27; : &#x27; 還沒(Q A Q)&#x27; &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="嘗試為頁面新增互動"><a href="#嘗試為頁面新增互動" class="headerlink" title="嘗試為頁面新增互動"></a>嘗試為頁面新增互動</h2><h3 id="類式組件中方法的-this-指向"><a href="#類式組件中方法的-this-指向" class="headerlink" title="類式組件中方法的 this 指向?"></a>類式組件中方法的 this 指向?</h3><ol><li><p>幫頁面中的<code>&lt;h2&gt;</code>新增<code>onClick</code>事件</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">false</span> &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; vaccinated &#125; = <span class="hljs-built_in">this</span>.state<br>        <span class="hljs-comment">// 用來測試作為實例調用是否正常</span><br>        <span class="hljs-built_in">this</span>.changeVaccinated()<br>        <br>        <span class="hljs-comment">// 幫 &lt;h2&gt; 新增 onClick 事件，</span><br>        <span class="hljs-comment">// 需注意 React 的事件綁定改成用駝峰命名法，</span><br>        <span class="hljs-comment">// 並且調用方法要用 &#123;&#125; 包起來，</span><br>        <span class="hljs-comment">// 且要用 this 來調用函數，結尾不能加 ()</span><br>        <span class="hljs-comment">// 有加 () 會變成一開頁面就立即執行</span><br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.changeVaccinated</span> &#125;&gt;</span>你打疫苗了嗎? </span><br><span class="xml">            &#123; vaccinated ? &#x27; 已經打了(．▽．) b&#x27; : &#x27; 還沒(Q A Q)&#x27; &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>    &#125;<br>    <span class="hljs-comment">/* 接續下面 */</span><br></code></pre></td></tr></table></figure></li><li><p>並在類式組件內增加<code>onClick</code>所需調用的函數</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx">    <span class="hljs-comment">/* 承接上面 */</span><br>    <br>    <span class="hljs-comment">// 將 changeVaccinated 放進 Vaccine 的原型變數裡，供實例使用</span><br>    <span class="hljs-comment">// 通過 Vaccine 實例調用 changeVaccinated 時</span><br>    <br>    <span class="hljs-comment">// 由於 changeVaccinated 是作為 onClick 的&#x27;回調函數&#x27;</span><br>    <span class="hljs-comment">// 所以不是通過&#x27;實例&#x27;調用，而是&#x27;直接&#x27;調用。</span><br>    <br>    <span class="hljs-comment">// 類中的方法默認開啟了局部的嚴格模式，</span><br>    <span class="hljs-comment">// 所以 changeVaccinated 中的 this 為 undefined</span><br>    <span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>點擊<code>你打疫苗了嗎?</code>後，打開開發者工具 Console ，觀察 this 回傳值</p><p> <img src="https://i.imgur.com/A6jSC6U.png" alt="組件內 this 的指向"></p></li><li><p>總結 this 指向結果，作為<code>onClick</code>直接調用函數會無法指向實例。</p><p> <img src="https://i.imgur.com/swv0Vza.png" alt="this 調用"></p></li></ol><h3 id="解決類式組件中方法-this-指向的問題"><a href="#解決類式組件中方法-this-指向的問題" class="headerlink" title="解決類式組件中方法 this 指向的問題"></a>解決類式組件中方法 this 指向的問題</h3><ol><li><p>只要在<code>constructor</code>中，多加一行程式碼就能解決 this 指向問題</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">false</span> &#125;<br>        <br>        <span class="hljs-comment">// 增加這一行，解決 changeVaccinated 中的 this 指向</span><br>        <span class="hljs-comment">// 右邊的 this.changeVaccinated 會先找到自身原型上的 changeVaccinated</span><br>        <span class="hljs-comment">// 調用了 bind(this) 方法，並把 this 綁在實例身上</span><br>        <span class="hljs-comment">// 然後將這個方法放到自身新增的 changeVaccinated (左邊)</span><br>        <span class="hljs-built_in">this</span>.changeVaccinated = <span class="hljs-built_in">this</span>.changeVaccinated.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>點擊<code>你打疫苗了嗎?</code>後，打開開發者頁面的 Console，就會看到 this 指向實例，並且添加了<code>changeVaccinated</code>方法</p><p> ![bind(this) 解決指向問題]](<a href="https://i.imgur.com/jJl2WYw.png">https://i.imgur.com/jJl2WYw.png</a>)</p></li></ol><h3 id="這段程式碼整個流程如下圖"><a href="#這段程式碼整個流程如下圖" class="headerlink" title="這段程式碼整個流程如下圖"></a>這段程式碼整個流程如下圖</h3><p><img src="https://i.imgur.com/rrBeuZ6.png" alt="這段程式碼整個流程如下圖"></p><h4 id="bind-方法做了什麼"><a href="#bind-方法做了什麼" class="headerlink" title="bind() 方法做了什麼?"></a>bind() 方法做了什麼?</h4><p>bind() 方法做了兩件事<br>    1. 會建立一個新的函數。<br>    2. 會幫你改函數裡面的 this</p><h3 id="小測驗"><a href="#小測驗" class="headerlink" title="小測驗"></a>小測驗</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Youtube</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123; <br>            <span class="hljs-attr">subscribed</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">youtube</span>: <span class="hljs-string">&#x27;https://www.youtube.com/channel/UC-b2nGm0xLzic38Byti0VjA&#x27;</span>,<br>        &#125;<br>        <span class="hljs-built_in">this</span>.____A____ = <span class="hljs-built_in">this</span>.____B____.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; subscribed, youtube &#125; = <span class="hljs-built_in">this</span>.state<br><br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.subscribe</span> &#125;&gt;</span>你訂閱六角學院的 Youtube 了嗎? </span><br><span class="xml">            &#123; subscribed ? &#x27; σ`∀´)σ 訂閱了，哪次不訂閱&#x27; : </span><br><span class="xml">            &#x27; 我就幫到這了(ㆆᴗㆆ) &#x27; + youtube &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">gogogo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>(<span class="hljs-string">&#x27;趕快去唄 =͟͟͞͞( •̀д•́)&#x27;</span>)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Youtube</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure><p>A 和 B 答案分別是甚麼 <a href="#%E9%80%99%E6%AE%B5%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%95%B4%E5%80%8B%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%E5%9C%96">不知道的話請點我</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">右邊有答案<span class="hljs-comment">-----------------------------------------------------------------------------A: subscribe / B: gogogo！</span><br></code></pre></td></tr></table></figure><h3 id="嘗試新增互動，剛學-React-必踏入過一次的坑"><a href="#嘗試新增互動，剛學-React-必踏入過一次的坑" class="headerlink" title="嘗試新增互動，剛學 React 必踏入過一次的坑"></a>嘗試新增互動，剛學 React 必踏入過一次的坑</h3><ol><li><p>首先取得 state 裡面的<code>vaccinated</code>值</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>嘗試修改 state</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>    <span class="hljs-built_in">this</span>.state.vaccinated = !vaccinated<br>    <span class="hljs-comment">// 用來測試是否有更改值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.vaccinated)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>你會發現值確實有修改，但畫面不會變</p><p> <img src="https://i.imgur.com/rA3Ja4C.png" alt="你會發現值確實有修改，但畫面不會變"></p></li><li><p><strong>注意</strong>狀態( state )不可以直接修改<br><code>this.state.vaccinated = !vaccinated</code> 這行就是直接修改</p></li></ol><h2 id="使用-setState-來修改狀態"><a href="#使用-setState-來修改狀態" class="headerlink" title="使用 setState 來修改狀態"></a>使用 setState 來修改狀態</h2><ol><li><p>一樣先取得 state 裡面的<code>vaccinated</code>值</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 setState() 方法，<br> <strong>注意</strong>狀態( state )必須透過 setState 進行修改</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">vaccinated</span>: !vaccinated &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>這時畫面就能點擊切換</p><p> <img src="https://i.imgur.com/5igofn0.gif" alt="成功觸發切換"></p></li></ol><h2 id="state-的簡寫方式"><a href="#state-的簡寫方式" class="headerlink" title="state 的簡寫方式"></a>state 的簡寫方式</h2><p>使用<strong>類的基礎知識</strong>簡化 state</p><ol><li><p>這是原來的程式碼</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-built_in">this</span>.changeVaccinated = <span class="hljs-built_in">this</span>.changeVaccinated.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; vaccinated &#125; = <span class="hljs-built_in">this</span>.state<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.changeVaccinated</span> &#125;&gt;</span>你打疫苗了嗎? </span><br><span class="xml">            &#123; vaccinated ? &#x27; 已經打了(．▽．) b&#x27; : &#x27; 還沒(Q A Q)&#x27; &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">changeVaccinated</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">vaccinated</span>: !vaccinated &#125;)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>將 constructor 中的 state 拉出來</p><ul><li>類中可以直接寫賦值語句 = 往實例裡面追加屬性</li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-comment">// this.state = &#123; vaccinated: false &#125;</span><br>        <span class="hljs-built_in">this</span>.changeVaccinated = <span class="hljs-built_in">this</span>.changeVaccinated.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用賦值語句，拉出 constructor</span><br>    state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">false</span> &#125;<br><br>    <span class="hljs-comment">/* 以下省略 */</span><br></code></pre></td></tr></table></figure></li><li><p>將函數改成<strong>賦值語句</strong> + <strong>ES6 箭頭函數</strong>的寫法，並省略 constructor 裡面的 bind()</p><p> 利用箭頭函數的特點</p><ul><li>沒有自己的 this</li><li>使用 this 時，會找其外側函數的 this，作為箭頭函數 this 去使用</li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">    <span class="hljs-comment">/* 以上省略 */</span><br>    <br> <span class="hljs-comment">// changeVaccinated()&#123;</span><br> <span class="hljs-comment">//     const vaccinated = this.state.vaccinated</span><br> <span class="hljs-comment">//     this.setState(&#123; vaccinated: !vaccinated &#125;)</span><br> <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">// 改成 ES6 箭頭函數</span><br>    changeVaccinated = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">vaccinated</span>: !vaccinated &#125;)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li><li><p>省略整個 constructor，最後簡化結果</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vaccine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化狀態</span><br>    state = &#123; <span class="hljs-attr">vaccinated</span>: <span class="hljs-literal">false</span> &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123; vaccinated &#125; = <span class="hljs-built_in">this</span>.state<br>        <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">this.changeVaccinated</span> &#125;&gt;</span>你打疫苗了嗎? </span><br><span class="xml">            &#123; vaccinated ? &#x27; 已經打了(．▽．) b&#x27; : &#x27; 還沒(Q A Q)&#x27; &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>)<br>    &#125;<br>    <span class="hljs-comment">// 自定義方法 - 藥用賦值語句的型式 + 箭頭函數</span><br>    changeVaccinated = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> vaccinated = <span class="hljs-built_in">this</span>.state.vaccinated<br>        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">vaccinated</span>: !vaccinated &#125;)<br>    &#125;<br>&#125;<br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Vaccine</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br></code></pre></td></tr></table></figure></li></ol><h2 id="總結-State"><a href="#總結-State" class="headerlink" title="總結 State"></a>總結 State</h2><h3 id="什麼是-State"><a href="#什麼是-State" class="headerlink" title="什麼是 State ?"></a>什麼是 State ?</h3><ol><li>State 是組件中最重要的屬性，值是<strong>物件</strong>（可以包含多個 key-value）。</li><li>通過更新 State 重新渲染組件。</li></ol><h3 id="State-必須注意的要點"><a href="#State-必須注意的要點" class="headerlink" title="State 必須注意的要點"></a>State 必須注意的要點</h3><ol><li><p>組件中 render 方法中的 this 為組件的實例物件。</p></li><li><p>組件自訂義的函數中，this 為<code>undefined</code>如何解決?</p><ul><li>強制綁定 this：通過函數<code>bind()</code>方法</li><li>賦值語句 + 箭頭函數</li></ul></li><li><p>狀態資料，不能直接修改或更新，必須借助<code>setState()</code>來更新</p></li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/state-and-lifecycle.html">React 官網 - State &amp; 生命週期</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 類式組件</title>
    <link href="/2021/07/28/2021-7-28-react-classComponent/"/>
    <url>/2021/07/28/2021-7-28-react-classComponent/</url>
    
    <content type="html"><![CDATA[<h1 id="⚛️-React-類式組件"><a href="#⚛️-React-類式組件" class="headerlink" title="⚛️ React - 類式組件"></a>⚛️ React - 類式組件</h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹 class component 最基礎的起手式。</p><!-- more --><h2 id="React-起手式"><a href="#React-起手式" class="headerlink" title="React 起手式"></a>React 起手式</h2><ol><li><p>老規矩，先建立一個 HTML，並搭建好環境</p><p> <a href="/2021/07/26/2021-7-26-react-base/#React-%E8%B5%B7%E6%89%8B%E5%BC%8F">還不知道 HTML 起手式請點我</a></p></li></ol><h2 id="創建類式組件"><a href="#創建類式組件" class="headerlink" title="創建類式組件"></a>創建類式組件</h2><ol><li><p>在 script 中，創建類式組件</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 1. 創建類式組件，必須繼承 React 中 Component 這個組件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 類式組件必須要有 render</span><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// render 中的實例變數是 Demo</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;render 中的 this:&#x27;</span>, <span class="hljs-built_in">this</span>)<br>        <span class="hljs-comment">// 必須要有 return 返回值</span><br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是類式組件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 2.讓 React 自動渲染組件到頁面，需注意組件首字母大寫且閉合</span><br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br><br></code></pre></td></tr></table></figure></li><li><p>畫面呈現<br> <img src="https://i.imgur.com/UiHFfl6.png" alt="class component"></p></li><li><p>打開開發人員工具的 Console，可以看到類的實例變數 和 組件三大屬性<br> <img src="https://i.imgur.com/CWy1XsS.png" alt="開發人員工具"></p></li></ol><h2 id="執行組件後-React-做了什麼"><a href="#執行組件後-React-做了什麼" class="headerlink" title="執行組件後 React 做了什麼?"></a>執行組件後 React 做了什麼?</h2><ol><li>React 解析組件標籤，找到了 Demo 組件。</li><li>發現組件是使用類定義的，隨後 new 出來該類的實例，並通過該實例調用到原型上的 render 方法。</li><li>將返回的虛擬 DOM 轉為真實 DOM，隨後呈現在頁面中。</li></ol><h2 id="類式組件-5-大重點須知"><a href="#類式組件-5-大重點須知" class="headerlink" title="類式組件 5 大重點須知"></a>類式組件 5 大重點須知</h2><ol><li>組件首字母必須大寫</li><li>必須輸入<code>extends React.Component</code>繼承 React 中 Component 這個組件</li><li>類式組件內必須要有 render 渲染</li><li>必須要 return 返回值</li><li>讓 ReactDOM 渲染必須使用閉合標籤</li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/components-and-props.html">React 官網 - Components &amp; Props</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 函數式組件</title>
    <link href="/2021/07/28/2021-7-28-react-functionComponent/"/>
    <url>/2021/07/28/2021-7-28-react-functionComponent/</url>
    
    <content type="html"><![CDATA[<h1 id="React-函數式組件"><a href="#React-函數式組件" class="headerlink" title="React - 函數式組件"></a>React - 函數式組件</h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介紹 function component 最基礎的起手式，這裡還不會介紹到 Hook 的運用。</p><!-- more --><h2 id="React-起手式"><a href="#React-起手式" class="headerlink" title="React 起手式"></a>React 起手式</h2><ol><li><p>老規矩，先建立一個 HTML，並搭建好環境</p><p> <a href="/2021/07/26/2021-7-26-react-base/#React-%E8%B5%B7%E6%89%8B%E5%BC%8F">還不知道 HTML 起手式請點我</a></p></li></ol><h2 id="創建函數式組件"><a href="#創建函數式組件" class="headerlink" title="創建函數式組件"></a>創建函數式組件</h2><ol><li><p>在 script 中，創建函數式組件</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 1. 創建函數式組件，定義組件首字母要大寫</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 此處 this 是 undefined，因為 Babel 編譯後開啟嚴格模式</span><br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span> )<br>    <span class="hljs-comment">// 必須要有 return 返回值</span><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是函數式組件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 2.讓 React 自動渲染組件到頁面，需注意組件首字母大寫且閉合</span><br>ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ) )<br><br></code></pre></td></tr></table></figure></li><li><p>畫面呈現<br> <img src="https://i.imgur.com/RZeT2Df.png" alt="function component"></p></li><li><p>打開開發人員工具的 Components 頁面可以看到組件、屬性與版本<br> <img src="https://i.imgur.com/roztIxH.png" alt="開發人員工具"></p></li></ol><h2 id="執行組件後-React-做了什麼"><a href="#執行組件後-React-做了什麼" class="headerlink" title="執行組件後 React 做了什麼?"></a>執行組件後 React 做了什麼?</h2><ol><li>React 解析組件標籤，找到了 Demo 組件。</li><li>發現組件是使用函數定義的，隨後調用該函數，將返回的虛擬 DOM 轉為真實 DOM，隨後呈現在頁面中。</li></ol><h2 id="函數式組件-3-大重點須知"><a href="#函數式組件-3-大重點須知" class="headerlink" title="函數式組件 3 大重點須知"></a>函數式組件 3 大重點須知</h2><ol><li>組件首字母必須大寫</li><li>必須要 return 返回值</li><li>讓 ReactDOM 渲染必須使用閉合標籤</li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/components-and-props.html">React 官網 - Components &amp; Props</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 組件 與 模組</title>
    <link href="/2021/07/27/2021-7-27-react-component/"/>
    <url>/2021/07/27/2021-7-27-react-component/</url>
    
    <content type="html"><![CDATA[<h1 id="React-組件-與-模組"><a href="#React-組件-與-模組" class="headerlink" title="React - 組件 與 模組"></a>React - 組件 與 模組</h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提升開發效率，就要了解組件與模組的概念，用簡單的言語解說，並了解開發 React 所需要的開發者工具</p><!-- more --><h2 id="模組"><a href="#模組" class="headerlink" title="模組"></a>模組</h2><ol><li>什麼是模組? 向外提供特定功能的 JS 程序，一般就是一個 JS 文件。</li><li>為什麼要拆成模組呢? 隨著業務邏輯增加，代碼越來越多且複雜。</li><li>最終結果是更能重複利用 JS，簡化 JS 編寫，提高 JS 的效率。</li></ol><h3 id="模組化"><a href="#模組化" class="headerlink" title="模組化"></a>模組化</h3><p>當應用程式的 JS 都以模組來編寫，就是一個模組化的應用程式</p><h2 id="組件"><a href="#組件" class="headerlink" title="組件"></a>組件</h2><ol><li>什麼是組件? 用來實現局部功能效果的代碼和資源的集合體（HTML / CSS / JS / Image）。</li><li>為什麼拆成組件呢? 一個頁面的功能更複雜。</li><li>最終結果是重複利用代碼，簡化項目編寫，提高運行效率。<br><img src="https://i.imgur.com/REJTFyp.png" alt="React module"></li></ol><p><em>此為 React 官網作為範例</em><br>React 官網一看，大致上可以拆成三個組件（Header / Content / Menu），甚至還可以拆得更細。</p><h3 id="組件化"><a href="#組件化" class="headerlink" title="組件化"></a>組件化</h3><p>當應用程式是以多組件的方式完成，就是一個組件化的應用程式</p><h2 id="React-開發人員工具"><a href="#React-開發人員工具" class="headerlink" title="React 開發人員工具"></a>React 開發人員工具</h2><p>在正式開發組件之前，要先下載 React 開發人員工具</p><ol><li>打開 Chrome 線上應用程式商店</li><li>搜尋 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-TW">React Developer Tools</a> 並下載。</li><li>點擊瀏覽器右上方的 Google 擴充功能，把開發者工具釘選上去。<br> <img src="https://i.imgur.com/3Uz8xcM.png" alt="Google 擴充功能"></li><li>開發者工具會有三種顏色呈現方式<table><thead><tr><th align="center">圖案</th><th align="center">解說</th></tr></thead><tbody><tr><td align="center"><img src="https://i.imgur.com/IlEAqv5.png" alt="Unused React"></td><td align="center">灰色，表示當前網頁不是用 React 開發的</td></tr><tr><td align="center"><img src="https://i.imgur.com/H3FqcQp.png" alt="Developer React"></td><td align="center">紅色，表示當前網頁還處於開發者模式，未打包上線</td></tr><tr><td align="center"><img src="https://i.imgur.com/5M7z7Gc.png" alt="Go live"></td><td align="center">藍色，表示當前網頁已打包上線</td></tr></tbody></table></li><li>按 F12 開發者工具內會新增兩個選項<br> <img src="https://i.imgur.com/MemNL3r.png" alt="Tools"><ul><li>Components 用來觀察網頁內有多少個組件組成的。</li><li>Profiler 用來記錄網站的性能。</li></ul></li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/components-and-props.html">React 官網 - Components &amp; Props</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 基礎</title>
    <link href="/2021/07/26/2021-7-26-react-base/"/>
    <url>/2021/07/26/2021-7-26-react-base/</url>
    
    <content type="html"><![CDATA[<h1 id="React-基礎"><a href="#React-基礎" class="headerlink" title="React - 基礎"></a>React - 基礎</h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>學習 React 中最重要的角色「Babel」，Babel 是 Javascript 的編譯器，有了 Babel 就能更方便順暢的使用 React</p><!-- more --><h2 id="React-基礎環境引入"><a href="#React-基礎環境引入" class="headerlink" title="React - 基礎環境引入"></a>React - 基礎環境引入</h2><ol><li>Babel<ul><li><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;</code></li></ul><ol><li>瀏覽器不認識 ES6，依靠 Babel 把 ES6 轉成 ES5</li><li>瀏覽器不認識 jsx，依靠 Babel 把 jsx 轉成 js</li><li>可以更流暢的編碼</li></ol></li><li>React 核心庫<ul><li><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot;&gt;&lt;/script&gt;</code></li></ul></li><li>React 擴展庫（讓 React 幫你操作 DOM）<ul><li><code>&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ol><h2 id="React-起手式"><a href="#React-起手式" class="headerlink" title="React 起手式"></a>React 起手式</h2><ol><li><p>首先建立一個 HTML</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-comment">&lt;!-- 先準備一個容器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引入 React 核心庫 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入 React DOM，用來讓 React 操作 DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入 Babel，用來將 jsx 轉成 js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 這裡一定要寫 type=&quot;text/babel&quot; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>並在 script 內編寫虛擬 DOM</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 1. 首先創建虛擬 DOM</span><br><span class="hljs-keyword">const</span> VDOM = &#123;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 2. 渲染虛擬 DOM 到頁面</span><br>ReactDOM.render( VDOM, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>) )<br></code></pre></td></tr></table></figure></li><li><p>畫面呈現<br> <img src="https://i.imgur.com/qh3CLyD.png" alt="Hello world"></p></li></ol><h2 id="React-jsx-語法規則-與-必須知道的地方"><a href="#React-jsx-語法規則-與-必須知道的地方" class="headerlink" title="React - jsx 語法規則 與 必須知道的地方"></a>React - jsx 語法規則 與 必須知道的地方</h2><ol><li><p>這時候 HTML 添加樣式</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.bg-hexschool</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background</span>: <span class="hljs-number">#69F0AE</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>script 內將內容用變數的方式展現</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 1. 宣告變數    </span><br><span class="hljs-keyword">const</span> myId = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-keyword">const</span> myData = <span class="hljs-string">&quot;Hello world&quot;</span><br><br><span class="hljs-comment">// 2. 建創虛擬 DOM</span><br><span class="hljs-keyword">const</span> VDOM = (<br>    <span class="hljs-comment">// 虛擬 DOM 只能有一個根標籤</span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    &#123;/* jsx 語法範例如下 */&#125;</span><br><span class="xml">    &#123;/* class 要改成 className */&#125;</span><br><span class="xml">    &#123;/* style 要用 &#123;&#123; key=value &#125;&#125; 包起來，並採用駝峰命名法 */&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">myId</span> &#125; </span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;bg-hexschool&quot;</span> </span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">fontSize:</span>&#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="xml">            &#123;/* JS 表達式都要用 &#123;&#125; 包起來，包含註解 */&#125;</span><br><span class="xml">            &#123; myData &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>虛擬 DOM 只能用一個標籤包起來<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        &#123;/* 標籤需要閉合，例如最後面加 &quot;/&quot; */&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     <span class="hljs-comment">// &lt;p&gt;這個沒有被包起來，會報錯&lt;/p&gt;</span><br>)<br><span class="hljs-comment">// 3. 渲染虛擬 DOM 到頁面</span><br>ReactDOM.render( VDOM, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>) )<br></code></pre></td></tr></table></figure></li><li><p>畫面呈現<br> <img src="https://i.imgur.com/1lrecAZ.png" alt="jsx 運用"></p></li></ol><h3 id="總結-jsx-語法規則"><a href="#總結-jsx-語法規則" class="headerlink" title="總結 jsx 語法規則"></a>總結 jsx 語法規則</h3><ol><li>定義虛擬 DOM 時，不要寫<strong>引號</strong>。</li><li>標籤中混入 JS 表達式要用 <code>&#123;&#125;</code> 包起來。</li><li>樣式的類名指定不要用 <code>class</code>，要用 <code>className</code>。</li><li>內聯樣式，要用 <code>style=&#123;&#123; key=value &#125;&#125;</code>的形式去寫。<ol><li>key 如果像是 <code>font-size</code>，要改成<strong>駝峰命名</strong> <code>fontSize</code>。</li><li>value 需要用<strong>引號</strong>包起來。</li></ol></li><li>虛擬 DOM 必須只有<strong>一個根標籤</strong></li><li>標籤必須<strong>閉合</strong></li><li>標籤首字母<ol><li>如果小寫開頭，則將把標籤轉為 HTML 中同名元素，如果 HTML 中無該標籤同名元素，則報錯。</li><li>如果大寫開頭，React 就去渲染對應的組件，如果組件沒有定義，則報錯</li></ol></li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://zh-hant.reactjs.org/docs/cdn-links.html">React 官網 - CDN 連結</a></li><li><a href="https://zh-hant.reactjs.org/docs/introducing-jsx.html">React 官網 - JSX 介紹</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React - 簡介</title>
    <link href="/2021/07/26/2021-7-26-react-introduction/"/>
    <url>/2021/07/26/2021-7-26-react-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="React-簡介"><a href="#React-簡介" class="headerlink" title="React - 簡介"></a>React - 簡介</h1><p><img src="https://i.postimg.cc/kMk16Gqq/icons8-react-160.png" alt="從 0 開始學 React"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這裡將會記錄我學習 React 的筆記，雖然說是從 0 開始學習，但該有的 Javascript 知識還是要有。</p><!-- more --><h3 id="學習-React-所需要的-Javascript-知識"><a href="#學習-React-所需要的-Javascript-知識" class="headerlink" title="學習 React 所需要的 Javascript 知識"></a>學習 React 所需要的 Javascript 知識</h3><ul><li><input checked="" disabled="" type="checkbox"> 判斷 this 指向</li><li><input checked="" disabled="" type="checkbox"> class 的概念</li><li><input checked="" disabled="" type="checkbox"> Javascript ES6 的語法規範</li><li><input checked="" disabled="" type="checkbox"> npm 套件管理工具</li><li><input checked="" disabled="" type="checkbox"> 繼承與原型鏈</li><li><input checked="" disabled="" type="checkbox"> 數列常用方法</li><li><input checked="" disabled="" type="checkbox"> 模組化</li></ul><h2 id="React-是什麼"><a href="#React-是什麼" class="headerlink" title="React 是什麼 ?"></a>React 是什麼 ?</h2><ul><li>React 是一個實作使用者介面的 JavaScript 函式庫。</li></ul><h2 id="誰開發的"><a href="#誰開發的" class="headerlink" title="誰開發的 ?"></a>誰開發的 ?</h2><ul><li>由 Facebook 開發，並且開源。</li></ul><h2 id="為什麼要學"><a href="#為什麼要學" class="headerlink" title="為什麼要學 ?"></a>為什麼要學 ?</h2><ol><li><p>原生 Javascript 操作 DOM 繁瑣，效率<strong>低</strong> ( DOM-API 操作 UI )。</p></li><li><p>使用 Javascript 直接操作 DOM，瀏覽器會<strong>大量重新</strong>繪製畫面。</p><p> <img src="https://i.imgur.com/MAar8Vs.png" alt="原生 JS 渲染畫面流程，每次新增資料，都會重新渲染畫面"></p></li><li><p>原生 Javascript 沒有<strong>組件化</strong>程式碼功能，程式碼重複利用率低。</p></li></ol><h2 id="React-的優點"><a href="#React-的優點" class="headerlink" title="React 的優點"></a>React 的優點</h2><ol><li><p>採用<strong>組件化</strong>模式，<strong>聲明式編碼</strong>，提高開發效率及組件複用率。</p><ul><li>聲明式編碼 與 命令式編碼 的差別<ul><li>命令式編碼: 透過 Javascript 或 JQuery 拿到要操作的 DOM，並命令它改樣式。<br>  生活中的例子：<blockquote><p>老師口渴想喝水，命令同學去哪個地方裝水。<br>這就是命令式編碼，其中少做任何步驟，老師都會喝不到水</p></blockquote></li><li>聲明式編碼: 透過一些特殊的語法，表達它是甚麼樣式，然後 React 自動幫你改了。<br>  生活中的例子：<blockquote><p>老師說喉嚨有點乾，同學自動站起來遞水過來。<br>這就是聲明式編碼</p></blockquote></li></ul></li></ul></li><li><p>React Native 中可以使用 React 語法進行<strong>移動端開發</strong>。</p></li><li><p>使用<strong>虛擬 DOM</strong> + 優秀的 <strong>Diffing 算法</strong>，盡量減少與真實 DOM 的直接作用。</p><p> <img src="https://i.imgur.com/3ibcbkp.png" alt="React 渲染畫面流程，每次新增資料，都會比對虛擬 DOM，不一樣的 DOM 才渲染上去"></p></li></ol><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLmOn9nNkQxJFJXLvkNsGsoCUxJLqyLGxu">React 全家桶</a></li><li><a href="https://reactjs.org/">React 官網</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程式語言</category>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
